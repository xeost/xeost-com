---
title: '100 Basic Backend Interview Questions'
description: 'Fundamentals, Databases, Networking, Security, Performance. This article covers the most common basic interview questions for backend developers.'
pubDate: 2025-08-16
author: 'Xeost'
# cover: assets/cover.png
recommend: false
tags: ['Interview Q&A', 'Backend']
---

This is a list of 100 language-agnostic basic backend interview questions for Backend developers. It covers the most common interview questions for backend developers, including fundamentals, databases, networking, security, and performance.

## Fundamentals

### What is the role of a backend server in a web application?

A backend server in a web application handles the server-side logic, processing requests from the frontend, managing data, and ensuring the application runs smoothly. It performs tasks like:

- **Data Management**: Interacts with databases to store, retrieve, update, or delete data.
- **Business Logic**: Executes the core functionality of the application, such as calculations, workflows, or rules.
- **API Handling**: Processes API requests and sends responses to the frontend or other clients.
- **Authentication/Authorization**: Manages user login, sessions, and access control.
- **Communication**: Facilitates interaction between the frontend, databases, and external services.
- **Performance & Scalability**: Handles load balancing, caching, and scaling to ensure reliability and speed.

In short, the backend server powers the application's functionality, acting as the backbone that supports the user interface and data flow.

### What is an API?

An API (Application Programming Interface) is a set of rules and tools that allows different software applications to communicate with each other. It acts as an intermediary, enabling the exchange of data or functionality between systems, such as a backend server and a frontend client, by defining standardized methods for requests and responses (e.g., GET, POST). For example, a backend API might provide data like user profiles or process actions like payments, which the frontend can access without needing to understand the backend's internal logic.

> [!important]+ **Example**: A simple To-Do List API
>
> **Base URL**: `https://api.todo-service.com/v1`
>
> - **GET** `/tasks` - Get all tasks
> - **GET** `/tasks/{id}` - Get a task by ID
> - **POST** `/tasks` - Create a new task
> - **PUT** `/tasks/{id}` - Update a task by ID
> - **DELETE** `/tasks/{id}` - Delete a task by ID

### What is the difference between frontend and backend development?

**Frontend Development**:

- Focuses on the user-facing part of a web application.
- Involves building the interface, visuals, and user interactions (e.g., buttons, forms, layouts).
- Uses technologies like HTML, CSS, JavaScript, and frameworks like React or Vue.js.
- Runs in the user's browser, handling client-side logic and rendering.
- Goal: Create an intuitive, responsive, and visually appealing user experience.

**Backend Development**:

- Focuses on the server-side logic, data management, and application functionality.
- Involves handling requests, processing data, managing databases, and ensuring system reliability.
- Uses technologies like Python, Java, Node.js, and databases like MySQL or MongoDB.
- Runs on the server, managing APIs, authentication, and business logic.
- Goal: Ensure the application is secure, scalable, and efficiently processes data.

**Key Difference**: Frontend is about what users see and interact with in the browser; backend is about the behind-the-scenes logic, data, and server operations that power the application.

### What is a server?

A **server** is a computer or software system that provides resources, services, or data to other computers (clients) over a network. In the context of a web application, it handles backend tasks such as processing requests, managing databases, executing business logic, and sending responses to clients (e.g., browsers or apps). Servers can be physical machines or virtual instances running software like Apache, Nginx, or Node.js, and they operate continuously to ensure availability and reliability of services.

### What is a request-response cycle?

The **request-response cycle** is the process in which a client (e.g., a web browser or app) communicates with a server to request resources or services, and the server processes the request and sends back a response.

**Steps in the Cycle**:

1. **Request**: The client sends an HTTP request to the server, specifying an action (e.g., GET, POST) and a resource (e.g., `/tasks`).
2. **Processing**: The server receives the request, processes it (e.g., retrieves data, performs logic, or updates a database), and prepares a response.
3. **Response**: The server sends back an HTTP response, typically containing data (e.g., JSON, HTML) or a status (e.g., 200 OK, 404 Not Found).

**Example**:

- A user clicks a link in a browser (client) to view a webpage (`GET /home`).
- The server processes the request, fetches the webpage content, and sends it back.
- The browser renders the response for the user to see.

This cycle is the foundation of client-server communication in web applications.

### What is HTTP?

HTTP (HyperText Transfer Protocol) is a protocol used for communication between clients (e.g., web browsers) and servers over the internet. It defines how requests and responses are structured and transmitted, enabling the retrieval of resources like web pages, images, or APIs.

Key points:

- **Stateless**: Each request-response cycle is independent.
- **Methods**: Includes actions like GET (retrieve data), POST (send data), PUT (update data), and DELETE (remove data).
- **Structure**: Requests contain headers, methods, and URLs; responses include status codes (e.g., 200 OK, 404 Not Found) and data.
- **Port**: Typically uses port 80 (or 443 for HTTPS).

HTTP is the foundation for data exchange in web applications.

### What are HTTP methods?

HTTP methods are standardized actions that define the type of operation a client (e.g., a browser or app) wants to perform on a server's resource (e.g., a webpage, API endpoint). They are part of the HTTP protocol and indicate the intended action in a request-response cycle. Below are the most common HTTP methods:

1. **GET**: Retrieve a resource or data from the server (e.g., fetch a webpage or list of tasks).
2. **POST**: Send data to the server to create a new resource (e.g., submit a form or create a new task).
3. **PUT**: Update an existing resource on the server (e.g., modify a task's details).
4. **DELETE**: Remove a resource from the server (e.g., delete a task).
5. **PATCH**: Partially update a resource (e.g., change only the status of a task).
6. **HEAD**: Retrieve metadata (headers) about a resource without the body, similar to GET.
7. **OPTIONS**: Query the server for supported HTTP methods or communication options.
8. **TRACE**: Echo the received request for debugging purposes (rarely used).
9. **CONNECT**: Establish a tunnel to the server, typically for proxying (e.g., for HTTPS).

Each method is used in specific contexts to interact with resources in a predictable and standardized way, forming the backbone of RESTful APIs and web communication.

### What is a URL?

A **URL** (Uniform Resource Locator) is a string that specifies the address of a resource on the internet, such as a webpage, file, or API endpoint. It provides a standardized way to locate and access resources over a network, typically via HTTP/HTTPS.

**Components of a URL**:

- **Scheme**: The protocol used (e.g., `http`, `https`).
- **Host**: The domain name or IP address of the server (e.g., `example.com`).
- **Port** (optional): The port number for the connection (e.g., `:80` for HTTP, often omitted).
- **Path**: The specific resource or endpoint on the server (e.g., `/tasks`).
- **Query Parameters** (optional): Key-value pairs for additional data (e.g., `?id=123`).
- **Fragment** (optional): A reference to a specific part of the resource (e.g., `#section1`).

**Example**:

`https://api.todo-service.com:443/v1/tasks?id=123#details`

- Scheme: `https`
- Host: `api.todo-service.com`
- Port: `443`
- Path: `/v1/tasks`
- Query: `id=123`
- Fragment: `details`

A URL acts as a precise address for accessing resources in web applications.

### What is a URI?

A **URI** (Uniform Resource Identifier) is a string that uniquely identifies a resource, either on the internet or within a system. It serves as a general way to reference resources, encompassing both **URLs** (Uniform Resource Locators) and **URNs** (Uniform Resource Names).

**Key Points**:

- **Purpose**: Identifies a resource by name, location, or both.
- **Types**:
  - **URL**: Specifies the location and how to access a resource (e.g., `https://api.todo-service.com/v1/tasks`).
  - **URN**: Identifies a resource by name without specifying its location (e.g., `urn:isbn:1234567890`).
- **Components** (for URLs, a subset of URIs):
  - Scheme (e.g., `https`, `ftp`).
  - Authority (e.g., domain like `example.com`).
  - Path (e.g., `/v1/tasks`).
  - Query (e.g., `?id=123`).
  - Fragment (e.g., `#section`).
- **Difference from URL**: All URLs are URIs, but not all URIs are URLs (e.g., URNs are URIs but don’t specify a location).

**Example**:

- URI (URL): `https://api.todo-service.com/v1/tasks?id=123`
- URI (URN): `urn:uuid:6e8bc430-9c3a-11d9-9669-0800200c9a66`

In backend development, URIs are used to define endpoints or resources in APIs and systems.

### What is FQDN?

An **FQDN** (Fully Qualified Domain Name) is the complete address of a specific resource on the internet, uniquely identifying a host within the domain name system (DNS). It includes the hostname and all domain levels, providing an absolute path to the resource.

**Key Points**:

- **Structure**: Consists of the hostname, subdomain (if any), second-level domain, and top-level domain (e.g., `api.todo-service.com`).
- **Purpose**: Used to locate servers or resources precisely in networking and web applications.
- **Example**:
  - `api.todo-service.com` is an FQDN, where:
    - `api` is the hostname.
    - `todo-service` is the second-level domain.
    - `com` is the top-level domain.
  - In contrast, `todo-service.com` is a domain name but not fully qualified without the hostname.
- **Usage in Backend**: FQDNs are used in DNS resolution, server configuration, APIs, and networking (e.g., specifying a server in a URL like `https://api.todo-service.com/v1/tasks`).

An FQDN ensures unambiguous identification of a resource across the internet.

### What is an endpoint in an API?

An **endpoint** in an API is a specific address (URL) that represents a resource or function in a web service, allowing clients to interact with the server by sending requests to perform actions like retrieving, creating, updating, or deleting data. Each endpoint is tied to a specific HTTP method (e.g., GET, POST) and path.

**Key Points**:

- **Structure**: Typically consists of a base URL and a path (e.g., `https://api.todo-service.com/v1/tasks`).
- **Purpose**: Defines a point of interaction for a specific operation (e.g., `GET /tasks` to list tasks or `POST /tasks` to create a task).
- **Example** (from a TODO service):
  - `GET /v1/tasks` - Retrieves all tasks.
  - `POST /v1/tasks` - Creates a new task.
  - `DELETE /v1/tasks/{id}` - Deletes a task by ID.

In backend development, endpoints are designed to handle specific client requests and return appropriate responses, forming the core of API functionality.

## Databases

### What is a database?

A **database** is an organized collection of data, typically stored and managed electronically on a computer system, designed to allow efficient storage, retrieval, updating, and deletion of data. In the context of backend development, it serves as a structured repository to store application data, such as user information, transactions, or content.

**Key Points**:

- **Purpose**: Enables persistent storage and management of data for applications.
- **Types**:
  - **Relational Databases**: Use tables with rows and columns (e.g., MySQL, PostgreSQL), managed with SQL.
  - **NoSQL Databases**: Handle unstructured or semi-structured data (e.g., MongoDB for documents, Redis for key-value stores).
- **Components**: Consists of tables (in relational databases), collections (in NoSQL), or other data structures, with mechanisms for querying and indexing.
- **Backend Role**: The backend interacts with the database to perform CRUD operations (Create, Read, Update, Delete) via APIs or direct queries.

For example, in a TODO service, a database might store tasks with fields like `id`, `title`, and `status`.

### What is SQL?

**SQL** (Structured Query Language) is a standardized programming language used to manage and manipulate relational databases. It enables users to perform operations such as querying, inserting, updating, and deleting data, as well as defining and managing database structures.

**Key Points**:

- **Purpose**: Interacts with relational databases to retrieve and manage data.
- **Common Operations**:
  - **SELECT**: Retrieve data (e.g., `SELECT * FROM tasks WHERE status = 'pending'`).
  - **INSERT**: Add data (e.g., `INSERT INTO tasks (title) VALUES ('New Task')`).
  - **UPDATE**: Modify data (e.g., `UPDATE tasks SET status = 'completed' WHERE id = 1`).
  - **DELETE**: Remove data (e.g., `DELETE FROM tasks WHERE id = 1`).
- **Additional Functions**: Defines schemas (e.g., creating tables), manages permissions, and supports joins for combining data across tables.
- **Used With**: Relational databases like MySQL, PostgreSQL, SQLite, or Oracle.

In backend development, SQL is used to interact with databases to support application logic, such as fetching or updating tasks in a TODO service.

### What is a primary key?

A **primary key** is a unique identifier for each record in a relational database table. It ensures that every row can be uniquely distinguished and is used to enforce data integrity and enable efficient data retrieval.

**Key Points**:

- **Uniqueness**: No two records in the table can have the same primary key value.
- **Non-null**: A primary key cannot contain null values.
- **Purpose**: Facilitates indexing, searching, and linking tables via foreign keys.
- **Example**: In a TODO service table `tasks`, a column `id` (e.g., `1`, `2`, `3`) can serve as the primary key to uniquely identify each task.
- **Implementation**: Typically an auto-incrementing integer or a unique string (e.g., UUID).

In backend development, primary keys are critical for database operations like querying or joining tables.

### What is a foreign key?

A **foreign key** is a column (or set of columns) in a relational database table that establishes a link between data in two tables. It references the primary key (or a unique key) of another table, ensuring referential integrity by enforcing that the value in the foreign key column matches an existing value in the referenced table's primary key or unique key.

**Key Points**:

- **Purpose**: Maintains relationships between tables, enabling data consistency and relational queries (e.g., joins).
- **Constraints**: Ensures the foreign key value exists in the referenced table or is null (if allowed).
- **Example**: In a TODO service:
  - Table `tasks`: Has columns `task_id` (primary key) and `title`.
  - Table `users`: Has columns `user_id` (primary key) and `name`.
  - Table `tasks` may have a `user_id` column as a foreign key referencing `users.user_id`, linking each task to a specific user.
- **Behavior**: Can enforce rules like cascading deletes/updates (e.g., if a user is deleted, their tasks are also deleted).

In backend development, foreign keys are used to model relationships and ensure data integrity across related tables.

### What is a table in a database?

A **table** in a database is a structured collection of data organized into rows and columns, used to store related information in a relational database. Each table represents a specific entity or concept (e.g., users, tasks) and is defined by a schema that specifies its columns and their data types.

**Key Points**:

- **Columns**: Define the attributes of the entity (e.g., `id`, `title`, `status` in a `tasks` table).
- **Rows**: Represent individual records or instances of the entity (e.g., a single task with values `1`, `"Buy groceries"`, `"pending"`).
- **Primary Key**: A unique column (or set of columns) to identify each row (e.g., `id`).
- **Purpose**: Organizes data for efficient storage, retrieval, and manipulation using queries (e.g., SQL).
- **Example**: In a TODO service, a `tasks` table might have columns `task_id` (primary key), `title`, `description`, and `due_date`.

In backend development, tables are fundamental for storing and managing application data, enabling operations like CRUD (Create, Read, Update, Delete).

### What is a row in a database?

A **row** in a database is a single record or entry in a relational database table that represents one instance of the entity defined by the table. Each row contains values for the columns defined in the table's schema, corresponding to the attributes of that entity.

**Key Points**:

- **Structure**: A row consists of data for each column in the table (e.g., for a `tasks` table with columns `task_id`, `title`, `status`, a row might be `1, "Buy groceries", "pending"`).
- **Uniqueness**: Typically identified by a primary key (e.g., `task_id`).
- **Purpose**: Stores a complete set of data for a single entity instance, such as one task in a TODO service.
- **Example**: In a `tasks` table:
  - Columns: `task_id`, `title`, `due_date`, `status`
  - Row: `1, "Complete project", "2025-10-01", "pending"`

In backend development, rows are manipulated through SQL queries (e.g., SELECT, INSERT, UPDATE, DELETE) to manage individual records in a database.

### What is a column in a database?

A **column** in a database is a single attribute or field in a relational database table that defines a specific type of data stored for each record (row) in that table. It represents a particular property of the entity the table describes.

**Key Points**:

- **Structure**: Each column has a name and a defined data type (e.g., integer, string, date) that specifies what kind of data it can hold.
- **Purpose**: Organizes data by categorizing it into specific attributes for all records in the table.
- **Example**: In a `tasks` table for a TODO service:
  - Columns: `task_id` (integer), `title` (string), `due_date` (date), `status` (string).
  - A row might contain: `1, "Buy groceries", "2025-10-01", "pending"`, where each value corresponds to a column.
- **Constraints**: Columns can have rules like `NOT NULL`, unique, or foreign key constraints to ensure data integrity.

In backend development, columns define the structure of the data stored in a table and are used in SQL queries to retrieve or manipulate specific attributes.

### What is CRUD?

**CRUD** stands for **Create, Read, Update, Delete**, representing the four fundamental operations used to manage data in a database or application. These operations are essential for interacting with persistent storage in backend development.

**Key Points**:

- **Create**: Adds new data to the database (e.g., inserting a new task in a TODO service).
  - Example: `INSERT INTO tasks (title, status) VALUES ('New Task', 'pending')`
- **Read**: Retrieves or queries data from the database (e.g., fetching a list of tasks).
  - Example: `SELECT * FROM tasks WHERE status = 'pending'`
- **Update**: Modifies existing data in the database (e.g., changing a task’s status).
  - Example: `UPDATE tasks SET status = 'completed' WHERE task_id = 1`
- **Delete**: Removes data from the database (e.g., deleting a task).
  - Example: `DELETE FROM tasks WHERE task_id = 1`

**Context**:

- **Backend Role**: CRUD operations are typically implemented in APIs (e.g., REST endpoints like `POST /tasks`, `GET /tasks`, `PUT /tasks/{id}`, `DELETE /tasks/{id}`).
- **Purpose**: Provides a standardized way to manage data, ensuring applications can store, retrieve, modify, and remove records efficiently.

In a TODO service, CRUD enables users to create tasks, view them, update their details, and delete them as needed.

### What is a query?

A **query** in a database is a request for data or instructions to retrieve, manipulate, or manage information stored in a database, typically written in a query language like SQL for relational databases. It specifies what data to access or how to modify it based on defined criteria.

**Key Points**:

- **Purpose**: Queries allow users or applications to interact with a database to perform operations like retrieving, inserting, updating, or deleting data (aligned with CRUD operations).
- **Types** (in SQL):
  - **SELECT**: Retrieves data (e.g., `SELECT title, status FROM tasks WHERE status = 'pending'`).
  - **INSERT**: Adds new data (e.g., `INSERT INTO tasks (title) VALUES ('New Task')`).
  - **UPDATE**: Modifies data (e.g., `UPDATE tasks SET status = 'completed' WHERE task_id = 1`).
  - **DELETE**: Removes data (e.g., `DELETE FROM tasks WHERE task_id = 1`).
- **Components**: Queries often include clauses like `WHERE` (filtering), `ORDER BY` (sorting), `JOIN` (combining tables), and `GROUP BY` (aggregating data).
- **Example**: In a TODO service, a query like `SELECT * FROM tasks WHERE due_date = '2025-10-01'` retrieves all tasks due on a specific date.

In backend development, queries are used to fetch or manipulate data in response to API requests or application logic, enabling dynamic interaction with the database.

### What is normalization?

**Normalization** is the process of organizing data in a relational database to eliminate redundancy, improve data integrity, and ensure efficient storage and retrieval. It involves structuring tables and their relationships according to a set of rules, called normal forms, to minimize data anomalies during CRUD operations (Create, Read, Update, Delete).

**Key Points**:

- **Purpose**: Reduces data duplication, ensures consistency, and simplifies maintenance.
- **Normal Forms** (simplified):
  - **1NF (First Normal Form)**: Ensures all columns contain atomic (indivisible) values and each record is unique (no duplicate rows).
  - **2NF**: Meets 1NF and ensures non-key columns are fully dependent on the primary key (eliminates partial dependencies).
  - **3NF**: Meets 2NF and ensures non-key columns are not dependent on other non-key columns (eliminates transitive dependencies).
- **Example**: In a TODO service:
  - Unnormalized table: A `tasks` table with columns `task_id`, `title`, `user_name`, `user_email` might repeat `user_name` and `user_email` for tasks by the same user.
  - Normalized:
    - `tasks` table: `task_id`, `title`, `user_id` (foreign key).
    - `users` table: `user_id`, `user_name`, `user_email`.
    - This splits user data into a separate table, reducing redundancy.
- **Benefits**: Saves storage space, ensures data consistency, and simplifies updates.
- **Trade-offs**: May increase query complexity (e.g., requiring joins) and impact performance for read-heavy applications.

In backend development, normalization is critical for designing efficient and maintainable database schemas, especially for applications like a TODO service where tasks and user data need clear relationships.

## Networking

### What is TCP?

**TCP** (Transmission Control Protocol) is a standard communication protocol used in computer networks to ensure reliable, ordered, and error-checked data transmission between devices over the internet or other networks. It operates at the transport layer of the OSI model and is a core component of the internet protocol suite (TCP/IP).

**Key Points**:

- **Reliability**: Guarantees delivery of data packets in the correct order without loss or duplication by using acknowledgments, retransmissions, and error detection.
- **Connection-Oriented**: Establishes a connection between sender and receiver via a three-way handshake (SYN, SYN-ACK, ACK) before data transfer and closes it afterward.
- **Flow Control**: Manages data flow to prevent overwhelming the receiver using mechanisms like sliding windows.
- **Error Handling**: Detects and corrects errors through checksums and retransmits lost packets.
- **Use Cases**: Used in applications requiring reliable data transfer, such as web browsing (HTTP/HTTPS), email (SMTP), and file transfers (FTP).
- **Example**: In a TODO service, when a client sends a `POST` request to `https://api.todo-service.com/v1/tasks` to create a task, TCP ensures the request and response data are delivered accurately and in sequence.

In backend development, TCP underpins reliable communication between clients and servers, ensuring API requests and responses are transmitted correctly.

### What is UDP?

**UDP** (User Datagram Protocol) is a lightweight communication protocol used in computer networks for transmitting data between devices. It operates at the transport layer of the OSI model, like TCP, but is designed for speed and efficiency rather than reliability.

**Key Points**:

- **Connectionless**: Does not establish a connection before sending data, unlike TCP's three-way handshake.
- **Unreliable**: Does not guarantee delivery, order, or error correction; packets may be lost, duplicated, or arrive out of sequence.
- **Low Overhead**: Minimal header size and no retransmission or flow control, making it faster than TCP.
- **Use Cases**: Ideal for applications where speed is critical and occasional data loss is acceptable, such as:
  - Real-time applications (e.g., video streaming, online gaming).
  - DNS queries.
  - VoIP (e.g., Zoom or Skype calls).
- **Example**: In a TODO service, UDP might be used for a real-time feature like broadcasting task updates to multiple clients, where low latency is prioritized over guaranteed delivery.

In backend development, UDP is used when performance is more critical than reliability, unlike TCP, which ensures accurate data transfer.

### What is IP?

**IP** (Internet Protocol) is a fundamental protocol in the internet protocol suite that enables communication between devices across networks, such as the internet or local networks. It operates at the network layer of the OSI model and is responsible for addressing and routing data packets from a source to a destination.

**Key Points**:

- **Purpose**: Defines how data packets are formatted, addressed, transmitted, and routed across networks.
- **Addressing**: Assigns unique IP addresses to devices to identify them (e.g., `192.168.1.1` for IPv4 or `2001:db8::1` for IPv6).
- **Versions**:
  - **IPv4**: Uses 32-bit addresses (e.g., `192.168.0.1`), limited to ~4.3 billion unique addresses.
  - **IPv6**: Uses 128-bit addresses (e.g., `2001:0db8:85a3::8a2e:0370:7334`), designed to handle more devices.
- **Functions**:
  - **Packet Routing**: Directs packets through routers to reach the destination IP address.
  - **Fragmentation**: Breaks data into smaller packets for transmission and reassembles them if needed.
- **Connectionless**: Sends packets independently without establishing a connection (unlike TCP).
- **Example**: In a TODO service, when a client sends a request to `https://api.todo-service.com/v1/tasks`, the IP protocol routes the request to the server’s IP address (e.g., `93.184.216.34`).

In backend development, IP ensures data packets reach the correct server or client, forming the foundation for protocols like TCP and UDP to handle reliable or fast communication.

### What is a port?

A **port** is a virtual point in a computer’s networking system used to identify specific processes or services on a device, allowing multiple applications to communicate over a network simultaneously. It is a 16-bit number (0 to 65535) associated with an IP address to direct data to the correct application or service.

**Key Points**:

- **Purpose**: Differentiates between different services or applications running on the same device, enabling targeted data delivery.
- **Types**:
  - **Well-Known Ports** (0–1023): Reserved for common services (e.g., port 80 for HTTP, 443 for HTTPS, 22 for SSH).
  - **Registered Ports** (1024–49151): Used for specific applications or services.
  - **Dynamic/Private Ports** (49152–65535): Temporarily assigned for client-side connections.
- **How It Works**: Combines with an IP address to form a complete network address (e.g., `192.168.1.1:80` specifies HTTP traffic to a server at that IP).
- **Example**: In a TODO service, a client sending a request to `https://api.todo-service.com:443/v1/tasks` uses port 443 (HTTPS) to communicate with the server’s web service, while the server might use port 3306 internally for MySQL database connections.

In backend development, ports are critical for routing network traffic to the appropriate application or service, ensuring proper communication between clients and servers.

### What is DNS?

**DNS** (Domain Name System) is a protocol and distributed system that translates human-readable domain names (e.g., `api.todo-service.com`) into machine-readable IP addresses (e.g., `93.184.216.34`) to locate devices or services on a network, such as the internet.

**Key Points**:

- **Purpose**: Acts like a phonebook for the internet, mapping domain names to IP addresses so clients can access servers without needing to know their numeric addresses.
- **How It Works**:
  - A client (e.g., a browser) sends a DNS query to a DNS resolver.
  - The resolver contacts DNS servers (e.g., root, TLD, and authoritative servers) to find the corresponding IP address.
  - The IP address is returned, allowing the client to connect to the server.
- **Components**:
  - **Domain Name**: Hierarchical name (e.g., `subdomain.example.com`).
  - **DNS Resolver**: A server that processes DNS queries.
  - **DNS Records**: Data types like A (IPv4 address), AAAA (IPv6), CNAME (alias), or MX (mail server).
- **Example**: In a TODO service, when a client accesses `https://api.todo-service.com/v1/tasks`, DNS resolves `api.todo-service.com` to an IP address like `192.168.1.1` to locate the server.
- **Port Usage**: DNS typically uses port 53 for queries (often over UDP for speed, sometimes TCP for larger responses).

In backend development, DNS is critical for enabling clients to find and connect to servers hosting APIs or web services using domain names.

### What is a socket?

A **socket** is an endpoint for communication between two devices (e.g., a client and a server) over a network. It is a software interface that enables data exchange using protocols like TCP or UDP, combining an IP address and a port number to identify a specific process or service on a device.

**Key Points**:

- **Purpose**: Facilitates bidirectional communication, allowing applications to send and receive data across networks (e.g., the internet).
- **Components**: A socket is defined by:
  - **IP Address**: Identifies the device (e.g., `192.168.1.1`).
  - **Port Number**: Identifies the specific application or service (e.g., `443` for HTTPS).
  - **Protocol**: TCP (reliable, connection-oriented) or UDP (fast, connectionless).
- **Types**:
  - **Stream Sockets**: Use TCP for reliable, ordered data transfer (e.g., HTTP requests).
  - **Datagram Sockets**: Use UDP for faster, unreliable data transfer (e.g., streaming).
- **Example**: In a TODO service, when a client sends a request to `https://api.todo-service.com:443/v1/tasks`, a socket is created on the client (e.g., `192.168.1.100:49152`) and server (e.g., `93.184.216.34:443`) to handle the HTTP communication over TCP.
- **Backend Role**: Servers listen on sockets (e.g., port 80 or 443) to accept incoming client connections, while clients create sockets to initiate requests.

In backend development, sockets are fundamental for enabling network communication, such as handling API requests or real-time data exchange (e.g., WebSockets for live updates).

### What is latency?

**Latency** is the time delay between a client's request and the server's response in a network or system. It measures how long it takes for data to travel from one point to another or for a system to process a request.

**Key Points**:

- **Definition**: The duration (usually in milliseconds) from initiating an action (e.g., sending an HTTP request) to receiving the first response.
- **Causes**:
  - Network delays (e.g., distance, routing, or congestion).
  - Server processing time (e.g., database queries, computation).
  - Application inefficiencies (e.g., unoptimized code).
- **Example**: In a TODO service, if a client sends a `GET /tasks` request to `https://api.todo-service.com`, latency is the time from sending the request to receiving the first byte of the response (e.g., 50ms for a fast server, 500ms for a distant or slow one).
- **Impact**: High latency can degrade user experience, especially in real-time applications like video calls or interactive APIs.
- **Measurement**: Often measured as round-trip time (RTT) in networking or response time in APIs.

In backend development, minimizing latency is critical for performance, achieved through optimizations like caching, efficient database queries, or using content delivery networks (CDNs).

### What is bandwidth?

**Bandwidth** is the maximum rate at which data can be transferred over a network connection, typically measured in bits per second (bps), such as Mbps (megabits per second) or Gbps (gigabits per second). It represents the capacity of a network link to handle data traffic.

**Key Points**:

- **Definition**: The volume of data that can be transmitted in a given time, akin to the width of a pipe for data flow.
- **Factors Affecting Bandwidth**:
  - Network infrastructure (e.g., fiber vs. copper cables).
  - Network congestion or shared usage.
  - Hardware limitations (e.g., routers, network cards).
- **Example**: In a TODO service, if a server has a bandwidth of 100 Mbps, it can theoretically handle 100 megabits of data per second for API requests and responses (e.g., sending large lists of tasks or media files).
- **Difference from Latency**: Bandwidth is about capacity (how much data), while latency is about speed (how fast data travels).
- **Impact**: Low bandwidth can lead to slow data transfers, especially for large payloads, affecting user experience in high-traffic applications.

In backend development, bandwidth is critical for ensuring servers can handle multiple client requests efficiently, especially for data-intensive operations like streaming or bulk API responses.

### What is a firewall?

A **firewall** is a network security device or software that monitors and controls incoming and outgoing network traffic based on predefined security rules. It acts as a barrier between a trusted internal network and untrusted external networks (e.g., the internet) to protect systems from unauthorized access and threats.

**Key Points**:

- **Purpose**: Filters traffic to prevent malicious activities, such as hacking, malware, or unauthorized data access.
- **How It Works**: Examines packets (data units) and allows, blocks, or redirects them based on rules (e.g., IP addresses, ports, protocols).
- **Types**:
  - **Hardware Firewall**: Physical device between networks (e.g., a router with firewall capabilities).
  - **Software Firewall**: Runs on a server or device (e.g., Windows Defender Firewall).
  - **Network-Based**: Protects entire networks (e.g., enterprise firewalls).
  - **Host-Based**: Protects individual devices.
- **Rules Examples**:
  - Allow `HTTPS` traffic on port 443.
  - Block incoming traffic from a specific IP address.
- **Example**: In a TODO service, a firewall might allow `GET /tasks` requests to `https://api.todo-service.com:443` only from trusted IP ranges and block suspicious traffic to prevent attacks like DDoS.
- **Advanced Features**: Can include intrusion detection, VPN support, or deep packet inspection.

In backend development, firewalls are critical for securing servers hosting APIs or databases, ensuring only legitimate traffic reaches the application.

### What is NAT?

**NAT** (Network Address Translation) is a technique used in networking to map one IP address space to another by modifying network address information in the IP header of packets while they are in transit. It is typically implemented in routers or firewalls to manage IP address allocation and enable communication between networks, especially when private IP addresses are used.

**Key Points**:

- **Purpose**: Allows multiple devices on a private network (e.g., home or office) to share a single public IP address for accessing external networks (e.g., the internet).
- **How It Works**:
  - Translates private IP addresses (e.g., `192.168.1.10`) to a public IP address (e.g., `203.0.113.1`) for outgoing traffic.
  - Maintains a translation table to route responses back to the correct private IP and port.
- **Types**:
  - **Static NAT**: Maps a private IP to a specific public IP (one-to-one).
  - **Dynamic NAT**: Maps private IPs to a pool of public IPs (temporary assignments).
  - **PAT (Port Address Translation)**: Maps multiple private IPs to a single public IP using different port numbers (most common, also called NAT overload).
- **Example**: In a TODO service, a server behind a NAT-enabled router with a private IP (`192.168.1.100`) sends API responses to clients on the internet via a public IP (`93.184.216.34`). The router uses NAT to translate the private IP to the public IP and tracks the connection using ports.
- **Benefits**:
  - Conserves public IP addresses.
  - Provides a layer of security by hiding internal network structures.
- **Drawbacks**: Can complicate direct inbound connections (e.g., peer-to-peer apps) unless configured with port forwarding.

In backend development, NAT is critical for managing server connectivity in private networks, enabling APIs or services to communicate with external clients while maintaining security and efficient IP usage.

## Security

### What is authentication?

**Authentication** is the process of verifying the identity of a user, device, or system attempting to access a resource or application. It ensures that the entity making a request is who or what it claims to be.

**Key Points**:

- **Purpose**: Confirms identity to prevent unauthorized access to sensitive resources (e.g., APIs, databases).
- **Common Methods**:
  - **Password-Based**: User provides a username and password (e.g., logging into a TODO service).
  - **Token-Based**: Uses tokens like JWT (JSON Web Tokens) or API keys for programmatic access.
  - **Multi-Factor Authentication (MFA)**: Combines multiple credentials (e.g., password + SMS code).
  - **OAuth**: Delegates authentication to a third-party provider (e.g., "Login with Google").
  - **Biometrics**: Uses fingerprints or facial recognition.
- **Example**: In a TODO service, when a user logs in with an email and password to access `https://api.todo-service.com/v1/tasks`, the backend verifies the credentials against a stored user database before granting access.
- **Outcome**: Successful authentication typically results in a session, token, or access grant, allowing the user to interact with protected resources.

In backend development, authentication is critical for securing APIs and ensuring only authorized users can perform actions like creating or viewing tasks.

### What is authorization?

**Authorization** is the process of determining whether an authenticated user, device, or system has permission to access specific resources or perform certain actions within an application or system. It occurs after authentication and focuses on what the entity is allowed to do.

**Key Points**:

- **Purpose**: Enforces access control to ensure users or systems only interact with resources or operations they are permitted to access.
- **How It Works**: The system checks the authenticated entity's permissions or roles against predefined rules or policies.
- **Common Methods**:
  - **Role-Based Access Control (RBAC)**: Permissions are assigned based on roles (e.g., admin, user).
  - **Attribute-Based Access Control (ABAC)**: Permissions are based on attributes (e.g., user location, department).
  - **Access Control Lists (ACLs)**: Define specific permissions for individual users or groups.
- **Example**: In a TODO service:
  - After authentication, a user might be authorized to view their own tasks (`GET /v1/tasks`) but not another user’s tasks.
  - An admin might be authorized to delete any task (`DELETE /v1/tasks/{id}`), while a regular user cannot.
- **Difference from Authentication**:
  - Authentication verifies _who_ you are (e.g., valid login credentials).
  - Authorization determines _what_ you can do (e.g., read or modify specific data).

In backend development, authorization is critical for securing APIs and ensuring users or clients only access resources or perform actions within their permitted scope, protecting data integrity and privacy.

### What is encryption?

**Encryption** is the process of converting readable data (plaintext) into an unreadable format (ciphertext) using an algorithm and a key to protect its confidentiality. It ensures that only authorized parties with the correct key can decrypt and access the original data.

**Key Points**:

- **Purpose**: Secures sensitive data during storage or transmission to prevent unauthorized access, interception, or tampering.
- **Types**:
  - **Symmetric Encryption**: Uses the same key for encryption and decryption (e.g., AES). Fast but requires secure key sharing.
  - **Asymmetric Encryption**: Uses a pair of keys (public and private) for encryption and decryption (e.g., RSA). Slower but secure for key exchange.
- **Use Cases**:
  - Protecting data in transit (e.g., HTTPS for API requests in a TODO service).
  - Securing stored data (e.g., encrypting user passwords in a database).
  - Ensuring secure communication (e.g., SSL/TLS for web servers).
- **Example**: In a TODO service, when a client sends a `POST /v1/tasks` request over HTTPS, the data (e.g., task details) is encrypted using TLS to prevent eavesdropping during transmission.
- **Components**:
  - **Plaintext**: Original data (e.g., "Create new task").
  - **Ciphertext**: Encrypted data (e.g., "X7aP9qZ...").
  - **Key**: Secret used to encrypt/decrypt (e.g., a 256-bit AES key).
  - **Algorithm**: Mathematical process (e.g., AES, RSA).

In backend development, encryption is critical for securing sensitive data, such as user credentials or API payloads, ensuring privacy and compliance with security standards.

### What is HTTPS?

**HTTPS** (HyperText Transfer Protocol Secure) is an extension of HTTP that uses encryption to secure communication between a client (e.g., a web browser or app) and a server over a network, typically the internet. It ensures data privacy, integrity, and authentication.

**Key Points**:

- **Purpose**: Protects data in transit from eavesdropping, tampering, or interception by encrypting it with protocols like TLS (Transport Layer Security) or its predecessor, SSL (Secure Sockets Layer).
- **How It Works**:
  - Uses **TLS/SSL** to encrypt HTTP requests and responses.
  - Authenticates the server using digital certificates issued by trusted Certificate Authorities (CAs).
  - Establishes a secure connection via a handshake process, ensuring only the client and server can read the data.
- **Key Features**:
  - **Encryption**: Scrambles data (e.g., API payloads) to prevent unauthorized access.
  - **Data Integrity**: Ensures data isn’t altered during transmission.
  - **Server Authentication**: Verifies the server’s identity (e.g., confirms `api.todo-service.com` is legitimate).
- **Example**: In a TODO service, a client sending a `POST /v1/tasks` request to `https://api.todo-service.com` uses HTTPS (port 443) to encrypt task data, ensuring it’s secure from interception.
- **Difference from HTTP**: HTTP is unencrypted and vulnerable to attacks like man-in-the-middle; HTTPS adds a secure layer.
- **Indicator**: Websites using HTTPS show a padlock icon in browsers and start with `https://`.

In backend development, HTTPS is essential for securing API endpoints, protecting user data (e.g., login credentials, task details), and ensuring trust in web applications.

### What is a password hash?

A **password hash** is a one-way transformation of a password into a fixed-length string of characters using a cryptographic hash function. It is used to securely store passwords in a database, making it difficult for attackers to retrieve the original password even if the database is compromised.

**Key Points**:

- **Purpose**: Protects passwords by storing them in an irreversible, encrypted form instead of plaintext.
- **How It Works**:
  - A hash function (e.g., bcrypt, SHA-256, Argon2) processes the password to produce a unique hash.
  - The hash is stored in the database instead of the actual password.
  - During login, the provided password is hashed and compared to the stored hash to verify authenticity.
- **Key Features**:
  - **One-Way**: Cannot be reversed to retrieve the original password.
  - **Deterministic**: The same password always produces the same hash (for verification).
  - **Collision-Resistant**: Different passwords should produce different hashes.
- **Salting**: A random string (salt) is added to the password before hashing to prevent attacks using precomputed tables (e.g., rainbow tables).
- **Example**: In a TODO service:
  - User password: `"MySecurePass123"`
  - Salt: `randomSalt123`
  - Hashed result (using bcrypt): `$2b$10$randomSalt123...hashedValue`
  - Stored in the `users` table for authentication during login.
- **Common Hash Functions**:
  - **bcrypt**: Adaptive, slow by design to resist brute-force attacks.
  - **Argon2**: Memory-hard, resistant to GPU-based attacks.
  - **SHA-256**: Faster but less secure for passwords without proper salting.

In backend development, password hashing is critical for securely storing user credentials, ensuring that even if a database is breached, the original passwords remain protected.

### What is SQL injection?

**SQL injection** is a security vulnerability in which an attacker manipulates a web application's database query by injecting malicious SQL code into user inputs (e.g., forms, URL parameters, or API payloads). This can allow unauthorized access to or manipulation of the database.

**Key Points**:

- **How It Works**: Attackers exploit poorly sanitized input fields to inject SQL commands that the database executes, altering the intended query behavior.
- **Impact**:
  - Unauthorized data access (e.g., retrieving all user data).
  - Data modification or deletion (e.g., changing or deleting tasks).
  - Bypassing authentication (e.g., logging in without valid credentials).
  - Potential database compromise or data leaks.
- **Example**: In a TODO service:
  - Normal query: `SELECT * FROM users WHERE username = 'john' AND password = 'pass123'`
  - Vulnerable input: User enters `' OR '1'='1` as the password.
  - Resulting query: `SELECT * FROM users WHERE username = 'john' AND password = '' OR '1'='1'`
  - This evaluates to true for all users, bypassing authentication.
- **Prevention**:
  - **Prepared Statements/Parameterized Queries**: Use placeholders for user inputs (e.g., `SELECT * FROM users WHERE username = ? AND password = ?`).
  - **Input Validation/Sanitization**: Restrict and clean user inputs to prevent malicious code.
  - **ORMs**: Use Object-Relational Mappers (e.g., SQLAlchemy, Sequelize) that handle inputs safely.
  - **Least Privilege**: Limit database user permissions to minimize damage.

In backend development, protecting against SQL injection is critical to secure database interactions in applications like a TODO service, ensuring user data and system integrity are maintained.

### What is XSS?

**XSS** (Cross-Site Scripting) is a security vulnerability in web applications where an attacker injects malicious scripts (typically JavaScript) into content that is then displayed to users. These scripts execute in the context of a victim’s browser, potentially compromising user data or interactions.

**Key Points**:

- **How It Works**: Attackers exploit unvalidated or unsanitized user inputs (e.g., form fields, URL parameters) to inject scripts that run when other users view the affected page or API response.
- **Types**:
  - **Stored XSS**: Malicious script is stored in the database and executed when users access the data (e.g., a comment with `<script>alert('hacked')</script>`).
  - **Reflected XSS**: Script is embedded in a URL or input and executed immediately when a user visits the manipulated link.
  - **DOM-Based XSS**: Script manipulates the browser’s Document Object Model (DOM) without server interaction.
- **Impact**:
  - Steal user data (e.g., cookies, session tokens).
  - Redirect users to malicious sites.
  - Deface websites or perform unauthorized actions (e.g., creating tasks in a TODO service).
- **Example**: In a TODO service:
  - An attacker submits a task title: `<script>stealCookies()</script>`.
  - If the title is displayed without sanitization, the script runs in users’ browsers when they view the task list.
- **Prevention**:
  - **Input Sanitization**: Escape or sanitize user inputs (e.g., convert `<` to `&lt;`).
  - **Output Encoding**: Encode data before rendering (e.g., use libraries like DOMPurify).
  - **Content Security Policy (CSP)**: Restrict script sources in browsers.
  - **Use Frameworks**: Modern frameworks (e.g., React, Angular) often escape outputs by default.
  - **Avoid eval()**: Never execute user input as code.

In backend development, preventing XSS is critical to protect users interacting with APIs or web interfaces, ensuring malicious scripts don’t compromise the application or user data in systems like a TODO service.

### What is CSRF?

**CSRF** (Cross-Site Request Forgery) is a security vulnerability in web applications where an attacker tricks an authenticated user into performing unintended actions on a trusted site without their knowledge or consent. It exploits the trust a website has in a user’s browser, which may automatically include credentials (e.g., cookies) with requests.

**Key Points**:

- **How It Works**: An attacker crafts a malicious request (e.g., via a link, image, or form) that, when triggered by a logged-in user, sends a request to the target site, leveraging the user’s active session to execute unauthorized actions.
- **Impact**:
  - Perform actions like changing account details, creating/deleting resources, or transferring funds.
  - Compromise user data or application integrity.
- **Example**: In a TODO service:
  - A user is logged into `https://api.todo-service.com`.
  - They visit a malicious site that includes an image tag: `<img src="https://api.todo-service.com/v1/tasks/delete/123">`.
  - The browser sends a `GET` request to delete task `123`, using the user’s session cookie, without their knowledge.
- **Prevention**:
  - **CSRF Tokens**: Include a unique, unpredictable token in legitimate requests (e.g., in forms or headers) that the server validates.
  - **SameSite Cookies**: Set cookies with `SameSite=Strict` or `SameSite=Lax` to restrict cross-site requests.
  - **Validate HTTP Methods**: Use POST instead of GET for state-changing actions and verify methods server-side.
  - **User Interaction**: Require explicit confirmation for sensitive actions (e.g., re-entering a password).
  - **CORS Policies**: Restrict cross-origin requests to trusted domains.

In backend development, preventing CSRF is crucial for securing APIs and web applications, ensuring that actions like creating or deleting tasks in a TODO service are performed only by authorized, intentional user requests.

### What is a session?

A **session** is a temporary, server-managed interaction between a client (e.g., a user's browser or app) and a server that maintains state information across multiple requests during a user's visit to a web application. It is used to track user activity, maintain login status, or store temporary data without requiring repeated authentication.

**Key Points**:

- **Purpose**: Preserves user-specific data (e.g., login status, preferences) across stateless HTTP requests.
- **How It Works**:
  - When a user logs in or starts interacting, the server creates a session and assigns a unique **session ID**.
  - The session ID is typically stored in a cookie or sent in requests (e.g., via headers).
  - The server stores session data (e.g., user ID, role) in memory, a database, or a cache (e.g., Redis).
  - The client includes the session ID in subsequent requests, allowing the server to retrieve the associated session data.
- **Example**: In a TODO service:
  - A user logs into `https://api.todo-service.com` with credentials.
  - The server creates a session, stores it (e.g., `session_id: abc123, user_id: 456`), and sends `abc123` to the client in a cookie.
  - When the user requests `GET /v1/tasks`, the browser sends the session ID, and the server verifies the user’s identity to return their tasks.
- **Features**:
  - **Expiration**: Sessions typically expire after a set time (e.g., 30 minutes) or on logout for security.
  - **Security**: Can be secured with HTTPS, secure cookies, and session tokens to prevent hijacking.
- **Session Storage**:
  - **Server-Side**: Session data stored on the server (e.g., in Redis, database).
  - **Client-Side**: Minimal data (session ID) stored in cookies or tokens (e.g., JWT for stateless sessions).
- **Use Case**: Maintains user authentication state, so a logged-in user can access protected endpoints like `POST /v1/tasks` without re-entering credentials.

In backend development, sessions are critical for managing user interactions in applications like a TODO service, ensuring a seamless and secure experience while maintaining state across requests.

### What is a cookie?

A **cookie** is a small piece of data stored by a web server on a client’s device (e.g., browser) and sent back to the server with subsequent requests. It is used to maintain state, track user activity, or store small amounts of information across HTTP requests, which are inherently stateless.

**Key Points**:

- **Purpose**: Enables persistence of user-specific data, such as session IDs, preferences, or tracking information, between requests.
- **How It Works**:
  - The server sends a cookie to the client via an HTTP response header (`Set-Cookie`).
  - The client (e.g., browser) stores the cookie and includes it in future requests to the same server via the `Cookie` header.
- **Components**:
  - **Name-Value Pair**: The key and data (e.g., `session_id=abc123`).
  - **Attributes**: Optional settings like:
    - `Expires` or `Max-Age`: When the cookie expires.
    - `Domain`: Which domains can access the cookie (e.g., `todo-service.com`).
    - `Path`: Which paths on the server the cookie applies to (e.g., `/v1`).
    - `Secure`: Ensures the cookie is only sent over HTTPS.
    - `HttpOnly`: Prevents client-side scripts from accessing the cookie (mitigates XSS).
    - `SameSite`: Controls cross-site request behavior (e.g., `Strict`, `Lax`, `None`).
- **Example**: In a TODO service:
  - After a user logs into `https://api.todo-service.com`, the server sends a cookie: `Set-Cookie: session_id=abc123; Secure; HttpOnly; SameSite=Strict`.
  - The browser stores it and includes `Cookie: session_id=abc123` in subsequent requests (e.g., `GET /v1/tasks`), allowing the server to identify the user.
- **Types**:
  - **Session Cookies**: Temporary, deleted when the browser closes.
  - **Persistent Cookies**: Stored until they expire or are deleted.
- **Use Cases**:
  - Maintaining user sessions (e.g., staying logged in).
  - Storing user preferences (e.g., theme settings).
  - Tracking user behavior (e.g., analytics).

In backend development, cookies are critical for managing sessions and user state in applications like a TODO service, but they must be secured (e.g., with `Secure` and `HttpOnly`) to prevent attacks like XSS or session hijacking.

## Performance

### What is caching?

**Caching** is the process of storing frequently accessed data or computed results in a temporary, fast-access storage layer (cache) to reduce latency, decrease server load, and improve performance in a system or application. Instead of repeatedly fetching or computing data from a slower source (e.g., database, disk, or network), the cache provides quick access to the stored copy.

**Key Points**:

- **Purpose**: Speeds up data retrieval, reduces resource usage, and enhances user experience.
- **How It Works**:
  - Data is stored in a cache (e.g., memory, Redis, or browser) after its first retrieval or computation.
  - Subsequent requests check the cache first; if the data is found (cache hit), it’s returned quickly; if not (cache miss), the data is fetched from the source and stored in the cache.
- **Types**:
  - **In-Memory Cache**: Stores data in RAM (e.g., Redis, Memcached) for fast access.
  - **Database Cache**: Stores query results to avoid redundant database queries.
  - **Client-Side Cache**: Stores data in the browser (e.g., HTTP caching with cookies or local storage).
  - **Distributed Cache**: Shared cache across multiple servers (e.g., in microservices).
- **Example**: In a TODO service:
  - A `GET /v1/tasks` request fetches a user’s task list from the database and stores it in a Redis cache with a key like `user:123:tasks`.
  - Future requests for the same user’s tasks check Redis first, avoiding a database query unless the cache expires or is invalidated.
- **Cache Management**:
  - **Expiration**: Data is removed after a set time (TTL, time-to-live) to ensure freshness.
  - **Invalidation**: Cache is updated or cleared when data changes (e.g., a task is updated).
  - **Eviction Policies**: Remove old data (e.g., LRU - Least Recently Used) when the cache is full.
- **Benefits**:
  - Reduces latency (faster responses).
  - Lowers database or server load.
  - Improves scalability for high-traffic applications.
- **Challenges**:
  - Cache staleness (outdated data).
  - Memory usage (caches can consume significant resources).
  - Consistency management (ensuring cache aligns with source data).

In backend development, caching is critical for optimizing API performance in applications like a TODO service, especially for frequently accessed data like task lists or user profiles.

### What is load time?

**Load time** is the duration it takes for a system, application, or resource (e.g., a webpage, API response, or database query) to fully process a request and deliver the requested data to the client. In the context of backend development, it typically refers to the time taken for a server to handle a request, including processing, querying databases, and returning a response.

**Key Points**:

- **Definition**: The total time from when a client sends a request (e.g., clicking a link or calling an API) to when the response is fully received and usable.
- **Components**:
  - **Network Latency**: Time for data to travel between client and server.
  - **Server Processing**: Time to execute backend logic, query databases, or fetch cached data.
  - **Data Transfer**: Time to send the response back to the client.
- **Example**: In a TODO service, the load time for a `GET /v1/tasks` request might include:
  - 50ms for network round-trip.
  - 100ms for the server to query the database and process the request.
  - 20ms to transfer the response (e.g., a JSON list of tasks).
  - Total load time: ~170ms.
- **Importance**: Affects user experience; faster load times improve responsiveness and satisfaction.
- **Optimization Techniques**:
  - Use caching (e.g., Redis) to reduce database query time.
  - Optimize database queries (e.g., indexing, avoiding unnecessary joins).
  - Implement content delivery networks (CDNs) for static assets.
  - Minimize payload size (e.g., compress JSON responses).

**Load Time** vs. **Latency**:

- **Scope**:
  - **Latency**: Measures the initial delay (time to first byte).
  - **Load Time**: Measures the entire process (request to complete response).
- **Focus**:
  - **Latency**: Focuses on network and initial server response speed.
  - **Load Time**: Includes latency plus server processing and data transfer.
- **Impact**:
  - High latency delays the start of a response, affecting perceived responsiveness.
  - High load time affects the overall user experience, especially for large responses.

In backend development, minimizing load time is critical for ensuring efficient API performance and a smooth user experience in applications like a TODO service.

### What is throughput?

**Throughput** is the rate at which a system processes or completes tasks, requests, or data transfers over a given period, typically measured in units like requests per second, transactions per second, or bytes per second. In backend development, it indicates the system’s capacity to handle workload efficiently.

**Key Points**:

- **Definition**: The number of operations or amount of data processed within a specific time frame.
- **Purpose**: Measures system performance and scalability under load, showing how many requests or tasks a server can handle.
- **Example**: In a TODO service:
  - If the server processes 100 `GET /v1/tasks` requests per second, the throughput is 100 requests/second.
  - For data transfer, if it sends 10 MB of task data per second, the throughput is 10 MB/s.
- **Factors Affecting Throughput**:
  - Server resources (CPU, memory, disk I/O).
  - Network bandwidth and latency.
  - Database performance (e.g., query efficiency).
  - Application optimization (e.g., caching, load balancing).
- **Difference from Latency**:
  - **Latency**: Time for a single request to get a response (e.g., 50ms for one `GET /v1/tasks`).
  - **Throughput**: Number of requests handled in a time period (e.g., 100 requests/second).
- **Importance**: High throughput indicates a system can handle many users or requests, critical for scalability in high-traffic applications.

In backend development, optimizing throughput (e.g., via caching, efficient queries, or load balancing) is key to ensuring a TODO service API can handle multiple users accessing tasks simultaneously without performance degradation.

### What is response time?

**Response time** is the total duration it takes for a system to process a request and return a complete response to the client. It measures the end-to-end time from when a client initiates a request (e.g., clicking a link or sending an API call) to when the client receives the full response, ready for use or rendering.

**Key Points**:

- **Definition**: The time elapsed from sending a request to receiving and processing the entire response.
- **Components**:
  - **Network Latency**: Time for the request to travel to the server and the response to return.
  - **Server Processing Time**: Time for the server to execute logic, query databases, or fetch data.
  - **Data Transfer Time**: Time to send the response data back to the client.
  - **Client-Side Processing** (optional): Time to render or process the response (e.g., in a browser).
- **Example**: In a TODO service, for a `GET /v1/tasks` request:
  - Network latency: 50ms (round-trip time).
  - Server processing: 100ms (database query and logic).
  - Data transfer: 20ms (sending JSON response).
  - Total response time: ~170ms.
- **Difference from Related Terms**:
  - **Latency**: Time to receive the first byte of the response (e.g., 50ms in the example above).
  - **Load Time**: Often synonymous with response time in backend contexts, but may include client-side rendering for web pages.
  - **Throughput**: Number of requests handled per unit time (e.g., 100 requests/second), not the time for a single request.
- **Importance**: Low response time improves user experience and application performance, especially for interactive systems like APIs.
- **Optimization**: Use caching (e.g., Redis), optimize database queries, reduce payload size, or leverage CDNs to lower response time.

In backend development, minimizing response time is critical for ensuring fast and efficient API interactions, such as retrieving task lists in a TODO service, enhancing user satisfaction and system scalability.

### What is scalability?

**Scalability** is the ability of a system, application, or infrastructure to handle increasing amounts of work (e.g., more users, requests, or data) or to be expanded to accommodate that growth without compromising performance or reliability.

**Key Points**:

- **Purpose**: Ensures a system can grow to meet rising demand while maintaining efficiency and user experience.
- **Types**:
  - **Vertical Scalability (Scaling Up)**: Adding more resources (e.g., CPU, RAM) to a single server to handle more load.
  - **Horizontal Scalability (Scaling Out)**: Adding more servers or instances to distribute the load across multiple machines.
- **Example**: In a TODO service:
  - **Vertical**: Upgrading the server’s CPU or memory to handle more `GET /v1/tasks` requests.
  - **Horizontal**: Adding more servers behind a load balancer to distribute API requests across multiple instances.
- **Factors Affecting Scalability**:
  - Architecture design (e.g., microservices vs. monolithic).
  - Efficient use of resources (e.g., caching, optimized queries).
  - Load balancing and distributed systems.
  - Database performance (e.g., sharding, replication).
- **Importance**: Critical for handling traffic spikes, user growth, or large datasets without slowdowns or downtime.
- **Challenges**: Increased complexity, cost, and potential for issues like data consistency in distributed systems.

In backend development, scalability ensures a TODO service API can support thousands of users accessing tasks concurrently, using techniques like load balancing, caching, or database sharding to maintain performance.

### What is vertical scaling?

**Vertical scaling**, also known as _scaling up_, is the process of increasing the capacity of a single server or system by adding more resources, such as CPU, RAM, storage, or network bandwidth, to handle increased workload or improve performance.

**Key Points**:

- **Purpose**: Enhances the ability of a single machine to process more requests, data, or computations without changing the system architecture.
- **How It Works**: Upgrade hardware or allocate more resources to the existing server (e.g., increasing from 4GB to 16GB RAM or from 2 to 8 CPU cores).
- **Example**: In a TODO service:
  - A server handling `GET /v1/tasks` requests struggles with 1,000 concurrent users.
  - Adding more RAM or a faster CPU to the server allows it to process more requests efficiently.
- **Advantages**:
  - Simple to implement (no architectural changes needed).
  - Minimal changes to application code or configuration.
  - Suitable for smaller-scale applications or quick performance boosts.
- **Disadvantages**:
  - Limited by hardware constraints (e.g., maximum CPU or RAM a server can support).
  - Expensive due to high-cost hardware upgrades.
  - Single point of failure (no redundancy if the server fails).
- **Contrast with Horizontal Scaling**: Vertical scaling adds power to one server, while horizontal scaling adds more servers to distribute the load.

In backend development, vertical scaling is a straightforward way to improve performance for applications like a TODO service API, but it’s less flexible than horizontal scaling for handling massive or unpredictable traffic growth.

### What is horizontal scaling?

**Horizontal scaling**, also known as _scaling out_, is the process of increasing a system's capacity by adding more servers or instances to distribute the workload across multiple machines, rather than upgrading a single server.

**Key Points**:

- **Purpose**: Enhances system performance and capacity by sharing the load across multiple nodes, improving scalability and reliability.
- **How It Works**: Additional servers or instances are added, and a load balancer distributes incoming requests (e.g., API calls) across them. Each server handles a portion of the workload.
- **Example**: In a TODO service:
  - A single server struggles with 10,000 concurrent `GET /v1/tasks` requests.
  - Adding three more servers and using a load balancer to distribute requests allows the system to handle the increased traffic efficiently.
- **Advantages**:
  - Virtually unlimited scalability (add as many servers as needed).
  - Improved fault tolerance (if one server fails, others continue to operate).
  - Cost-effective for large-scale systems (uses commodity hardware or cloud instances).
- **Disadvantages**:
  - Increased complexity (requires load balancing, distributed systems, and data consistency management).
  - May need application redesign (e.g., to handle stateless operations or distributed databases).
  - Potential for higher latency in some cases due to coordination overhead.
- **Contrast with Vertical Scaling**: Horizontal scaling adds more machines, while vertical scaling upgrades a single machine’s resources (e.g., CPU, RAM).
- **Technologies**: Often uses cloud platforms (e.g., AWS, Azure), containerization (e.g., Docker), and orchestration (e.g., Kubernetes) to manage multiple instances.

In backend development, horizontal scaling is critical for handling high traffic in applications like a TODO service API, ensuring performance and availability as user demand grows, especially in distributed systems.

### What is a bottleneck?

A **bottleneck** is a point in a system where the flow of data, requests, or processes is limited, causing reduced performance, slower response times, or decreased throughput. It occurs when a component (e.g., hardware, software, or network) cannot handle the workload efficiently, restricting the overall system's capacity.

**Key Points**:

- **Definition**: A bottleneck is like a narrow section of a pipe that restricts flow, slowing down the entire system.
- **Causes**:
  - **Hardware**: Insufficient CPU, RAM, or disk I/O capacity.
  - **Database**: Slow queries, lack of indexing, or high contention.
  - **Network**: Limited bandwidth or high latency.
  - **Software**: Inefficient code, single-threaded processes, or poor resource management.
- **Example**: In a TODO service:
  - A database query for `GET /v1/tasks` takes 500ms due to a missing index, slowing down API responses despite a fast server. The database is the bottleneck.
  - A server with limited CPU struggles to handle 10,000 concurrent requests, causing delays.
- **Impact**:
  - Increased response times or latency.
  - Reduced throughput (fewer requests processed per second).
  - Poor user experience or system failures under load.
- **Identification**: Use monitoring tools (e.g., Prometheus, New Relic) to detect slow components via metrics like CPU usage, query times, or request queues.
- **Solutions**:
  - Optimize code or queries (e.g., add database indexes).
  - Scale resources (vertical or horizontal scaling).
  - Implement caching (e.g., Redis for frequent queries).
  - Use load balancing to distribute traffic.

In backend development, identifying and resolving bottlenecks is critical for maintaining performance and scalability in applications like a TODO service, ensuring efficient handling of API requests and data processing.

### What is optimization?

**Optimization** is the process of improving a system, application, or process to enhance its performance, efficiency, or resource utilization while maintaining or improving functionality. It aims to reduce latency, increase throughput, minimize resource consumption (e.g., CPU, memory, or bandwidth), or improve scalability and reliability.

**Key Points**:

- **Purpose**: To make a system faster, more cost-effective, or capable of handling higher loads with better user experience.
- **Areas of Optimization**:
  - **Code**: Refactor inefficient algorithms or reduce complexity (e.g., from O(n²) to O(n log n)).
  - **Database**: Optimize queries (e.g., add indexes, reduce joins), use caching (e.g., Redis), or implement sharding.
  - **Network**: Minimize latency with CDNs, compress responses, or use efficient protocols (e.g., HTTP/2).
  - **Resources**: Optimize CPU, memory, or disk usage (e.g., via load balancing or vertical scaling).
  - **Scalability**: Design for horizontal scaling or use asynchronous processing.
- **Example**: In a TODO service:
  - Unoptimized: A `GET /v1/tasks` request takes 500ms due to a slow database query scanning an entire table.
  - Optimized: Adding an index to the `tasks` table reduces query time to 50ms, improving response time.
  - Caching the task list in Redis further reduces database load, boosting throughput.
- **Techniques**:
  - Caching frequently accessed data.
  - Indexing databases for faster queries.
  - Compressing data (e.g., Gzip for API responses).
  - Using asynchronous operations to handle concurrent requests.
  - Load balancing to distribute traffic across servers.
- **Trade-offs**: Optimization may increase complexity, development time, or maintenance costs (e.g., caching introduces consistency challenges).

In backend development, optimization is critical for ensuring a TODO service API delivers fast responses, handles high traffic, and uses resources efficiently, ultimately improving user satisfaction and system scalability.

### What is indexing in databases?

**Indexing** in databases is a technique used to improve the speed and efficiency of data retrieval by creating a data structure (an index) that allows the database to quickly locate and access records without scanning the entire table.

**Key Points**:

- **Purpose**: Reduces query execution time for operations like `SELECT`, `WHERE`, `JOIN`, or `ORDER BY` by providing a faster lookup mechanism.
- **How It Works**:
  - An index is a separate data structure (e.g., B-tree or hash table) that stores a subset of the table’s data, typically the values of one or more columns, along with pointers to the corresponding rows.
  - When a query is executed, the database uses the index to find matching rows instead of scanning the entire table.
- **Example**: In a TODO service:
  - Table: `tasks` with columns `task_id`, `title`, `status`, `due_date`.
  - Without an index, a query like `SELECT * FROM tasks WHERE status = 'pending'` scans all rows.
  - With an index on `status`, the database quickly locates rows where `status = 'pending'`, reducing query time (e.g., from 500ms to 50ms).
- **Types of Indexes**:
  - **Primary Index**: Automatically created for the primary key (e.g., `task_id`).
  - **Unique Index**: Ensures unique values in a column (e.g., `email` in a `users` table).
  - **Secondary Index**: Created on non-key columns to speed up queries (e.g., `due_date`).
  - **Composite Index**: Indexes multiple columns for complex queries (e.g., `status` and `due_date`).
  - **Clustered Index**: Determines the physical order of data in the table (usually one per table).
  - **Non-Clustered Index**: Separate from the table’s data, pointing to rows (can have multiple).
- **Benefits**:
  - Faster query performance (especially for large datasets).
  - Efficient filtering, sorting, and joining.
- **Trade-offs**:
  - Increased storage (indexes consume disk space).
  - Slower write operations (e.g., `INSERT`, `UPDATE`, `DELETE`) as indexes must be updated.
  - Maintenance overhead (indexes need to be rebuilt or optimized).
- **Use Case**: In a TODO service, indexing the `user_id` column in the `tasks` table speeds up queries like `SELECT * FROM tasks WHERE user_id = 123`, improving API response times for user-specific task lists.

In backend development, indexing is critical for optimizing database performance in applications like a TODO service, ensuring fast data retrieval while balancing write performance and storage costs.

## Concurrency

### What is a thread?

A **thread** is the smallest unit of execution within a process in a computer's operating system, allowing a program to perform multiple tasks concurrently. It represents a sequence of instructions that can be executed independently, sharing the same memory space and resources as other threads within the same process.

**Key Points**:

- **Purpose**: Enables concurrent execution of tasks, improving performance and responsiveness in applications.
- **How It Works**:
  - A process (e.g., a running application) can have multiple threads, each executing a specific task.
  - Threads share the process’s memory, file handles, and other resources, but each has its own stack and program counter.
- **Example**: In a TODO service:
  - A backend server handling `GET /v1/tasks` requests might use one thread to process incoming HTTP requests, another to query the database, and another to handle response formatting, all within the same server process.
- **Characteristics**:
  - **Lightweight**: Threads are less resource-intensive than processes, as they share resources.
  - **Concurrency**: Multiple threads can run simultaneously (on multi-core CPUs) or be scheduled by the OS.
  - **Context Switching**: The OS switches between threads, which is faster than switching between processes.
- **Use Cases**:
  - Handling multiple client requests in a web server (e.g., Node.js with async threads or Java with thread pools).
  - Parallel processing of tasks, like generating reports or processing task updates in a TODO service.
- **Challenges**:
  - **Race Conditions**: Multiple threads accessing shared data can cause inconsistencies.
  - **Deadlocks**: Threads waiting for each other to release resources can halt execution.
  - **Synchronization**: Requires mechanisms like mutexes or locks to manage shared resources safely.
- **Contrast with Process**:
  - A process is an independent program with its own memory space.
  - Threads within a process share memory and resources, making them more efficient for multitasking.

In backend development, threads are critical for building responsive and efficient systems, such as handling concurrent API requests in a TODO service, but they require careful management to avoid issues like race conditions or deadlocks.

### What is a process?

A **process** is an instance of a program that is actively running on a computer, managed by the operating system. It represents a self-contained execution environment with its own memory space, resources, and state, capable of performing tasks independently.

**Key Points**:

- **Purpose**: Executes a program’s instructions, handling tasks like computation, I/O operations, or network communication.
- **Components**:
  - **Code**: The program’s instructions (e.g., a web server application).
  - **Data**: Variables and memory allocated for the program.
  - **Stack**: Temporary storage for function calls and variables.
  - **Heap**: Dynamic memory allocation.
  - **Resources**: File handles, network sockets, and CPU time.
- **Example**: In a TODO service:
  - A web server (e.g., Node.js or Apache) runs as a process to handle API requests like `GET /v1/tasks`.
  - A database server (e.g., MySQL) runs as a separate process to manage queries.
- **Characteristics**:
  - **Isolation**: Each process has its own memory space, preventing interference with other processes.
  - **Heavyweight**: Processes require more resources than threads due to separate memory and resource allocation.
  - **Multitasking**: The OS schedules multiple processes to run concurrently, switching between them.
- **Contrast with Thread**:
  - A **process** is an independent program with its own memory and resources.
  - A **thread** is a lightweight unit of execution within a process, sharing the process’s memory and resources.
- **Use Cases**:
  - Running a backend server (e.g., for a TODO service API).
  - Executing a database instance or a background job (e.g., task scheduler).
- **Challenges**:
  - **Resource Usage**: Processes consume more memory and CPU than threads.
  - **Inter-Process Communication (IPC)**: Processes need mechanisms like pipes or message queues to communicate, which can be slower than thread communication.
  - **Context Switching**: Switching between processes is slower than switching between threads.

In backend development, processes are fundamental for running applications like a TODO service’s web server or database, enabling isolated and robust execution of tasks, while threads within a process handle concurrent subtasks for efficiency.

### What is multitasking?

**Multitasking** is the ability of a computer system or operating system to execute multiple tasks or processes concurrently, allowing multiple operations to appear to run simultaneously. It enables efficient use of system resources by rapidly switching between tasks or executing them in parallel, depending on the system's capabilities.

**Key Points**:

- **Purpose**: Improves system efficiency and responsiveness by allowing multiple activities (e.g., running applications, handling requests) to share CPU time.
- **How It Works**:
  - The operating system schedules tasks (processes or threads) using techniques like time-sharing or prioritization.
  - On a single-core CPU, multitasking is achieved through **context switching**, where the CPU rapidly alternates between tasks.
  - On multi-core CPUs, true parallel execution of tasks is possible.
- **Types**:
  - **Preemptive Multitasking**: The OS controls task switching, allocating time slices to each task (used in modern OS like Windows, Linux).
  - **Cooperative Multitasking**: Tasks voluntarily yield control to others (less common, used in older systems).
- **Example**: In a TODO service:
  - A backend server process handles multiple `GET /v1/tasks` API requests concurrently by using threads or asynchronous tasks.
  - Simultaneously, a database process runs queries, and a background process sends reminder emails, all managed by the OS.
- **Benefits**:
  - Improved responsiveness (e.g., users can interact with a TODO app while the server processes other requests).
  - Efficient resource utilization (CPU, memory).
- **Challenges**:
  - **Overhead**: Context switching consumes CPU time.
  - **Resource Contention**: Tasks competing for resources (e.g., CPU, memory) can cause bottlenecks.
  - **Synchronization**: Requires mechanisms like locks to prevent conflicts in shared resources.
- **Contrast with Related Terms**:
  - **Multithreading**: Multiple threads within a single process share the same memory and resources.
  - **Parallelism**: Simultaneous execution of tasks on multiple CPU cores.

In backend development, multitasking is critical for handling concurrent API requests, database operations, and background jobs in applications like a TODO service, ensuring the system remains responsive under load.

### What is parallelism?

**Parallelism** is the simultaneous execution of multiple tasks or processes on multiple processing units (e.g., CPU cores, processors, or machines) to improve performance and reduce processing time. Unlike multitasking, which may involve rapid switching between tasks on a single processor, parallelism involves true concurrent execution.

**Key Points**:

- **Purpose**: Increases efficiency by dividing a workload across multiple resources to process tasks at the same time, reducing overall execution time.
- **How It Works**:
  - Tasks are split into smaller, independent subtasks that can run concurrently on separate CPU cores, threads, or servers.
  - Requires hardware support (e.g., multi-core CPUs, GPUs, or distributed systems) and software designed to leverage parallelism.
- **Types**:
  - **Task Parallelism**: Different tasks run simultaneously (e.g., one thread handles API requests while another processes database queries).
  - **Data Parallelism**: The same operation is applied to different data chunks simultaneously (e.g., processing a large dataset across multiple cores).
- **Example**: In a TODO service:
  - A server with a multi-core CPU handles multiple `GET /v1/tasks` requests simultaneously, with each core processing a different request.
  - A batch job to update the status of thousands of tasks splits the workload across multiple threads or servers, each processing a subset of tasks in parallel.
- **Benefits**:
  - Faster execution for computationally intensive tasks.
  - Improved throughput for high-load systems.
  - Efficient use of multi-core or distributed systems.
- **Challenges**:
  - **Coordination Overhead**: Managing parallel tasks requires synchronization (e.g., locks, semaphores) to avoid conflicts.
  - **Complexity**: Writing parallel code is harder due to issues like race conditions or deadlocks.
  - **Resource Limits**: Dependent on available hardware (e.g., number of CPU cores).
- **Contrast with Multitasking**:
  - **Multitasking**: Tasks share a single processor via time-slicing, appearing to run concurrently.
  - **Parallelism**: Tasks run simultaneously on multiple processors or cores for true concurrency.
- **Technologies**: Supported by multi-threading (e.g., Java’s ThreadPool), task queues (e.g., Celery), or distributed frameworks (e.g., Apache Spark).

In backend development, parallelism is critical for scaling applications like a TODO service, enabling faster processing of API requests, database operations, or background jobs by leveraging multiple cores or servers.

### What is concurrency?

**Concurrency** is the ability of a system to manage multiple tasks or processes at the same time, allowing them to make progress without necessarily executing simultaneously. It focuses on handling multiple operations in an overlapping manner, often by interleaving their execution, to improve responsiveness and resource utilization.

**Key Points**:

- **Purpose**: Enables efficient handling of multiple tasks (e.g., user requests, computations) by allowing them to run in a coordinated way, even on a single processor.
- **How It Works**:
  - Tasks are executed in small chunks, with the system switching between them (e.g., via time-slicing in multitasking or asynchronous operations).
  - Concurrency does not require simultaneous execution (unlike parallelism); tasks may share a single CPU core.
- **Example**: In a TODO service:
  - A backend server handles multiple `GET /v1/tasks` requests concurrently by processing one request while waiting for a database query for another, using asynchronous I/O or threads.
  - A single-threaded Node.js server uses an event loop to concurrently manage API requests without blocking.
- **Types**:
  - **Thread-Based Concurrency**: Multiple threads within a process share resources and take turns executing (e.g., Java threads).
  - **Asynchronous Concurrency**: Tasks are managed using async operations (e.g., JavaScript’s `async/await` or Python’s `asyncio`), allowing non-blocking I/O.
  - **Event-Driven Concurrency**: Uses an event loop to handle tasks triggered by events (e.g., HTTP requests).
- **Benefits**:
  - Improved responsiveness (e.g., handling multiple API requests without waiting for each to complete).
  - Better resource utilization (e.g., CPU can work while waiting for I/O operations like database queries).
- **Challenges**:
  - **Race Conditions**: Multiple tasks accessing shared resources can cause inconsistencies.
  - **Deadlocks**: Tasks waiting for each other can halt progress.
  - **Complexity**: Requires synchronization mechanisms (e.g., locks, semaphores) to manage shared resources.
- **Contrast with Parallelism**:
  - **Concurrency**: Focuses on managing multiple tasks at once, interleaving their execution (e.g., on a single core).
  - **Parallelism**: Focuses on executing multiple tasks simultaneously on multiple cores or machines.
- **Example in Context**:
  - Concurrency: A TODO service API handles 100 simultaneous `POST /v1/tasks` requests by interleaving database writes and response preparation on a single CPU.
  - Parallelism: The same API uses multiple CPU cores to process those 100 requests simultaneously.

In backend development, concurrency is critical for building responsive and scalable systems like a TODO service, allowing efficient handling of multiple API requests or background tasks, especially in high-traffic scenarios.

### What is a mutex?

A **mutex** (short for mutual exclusion) is a synchronization mechanism used in concurrent programming to prevent multiple threads or processes from simultaneously accessing or modifying a shared resource, thereby avoiding race conditions and ensuring data consistency.

**Key Points**:

- **Purpose**: Ensures that only one thread or process can access a critical section of code or shared resource (e.g., memory, file, or database) at a time, preventing conflicts.
- **How It Works**:
  - A mutex acts like a lock: a thread must acquire the mutex before entering the critical section and release it when done.
  - If another thread tries to acquire the mutex while it’s held, it waits (blocks) until the mutex is released.
- **Example**: In a TODO service:
  - Multiple threads handle `POST /v1/tasks` requests to add tasks to a shared database.
  - A mutex ensures only one thread updates the `tasks` table at a time, preventing duplicate or inconsistent task IDs.
  - Code example (pseudocode):
    ```pseudo title="pseudo"
    mutex.lock()
    try {
        database.insert(new_task)
    } finally {
        mutex.unlock()
    }
    ```
- **Characteristics**:
  - **Exclusive Access**: Only one thread holds the mutex at a time.
  - **Blocking**: Threads attempting to acquire a locked mutex wait until it’s free.
  - **Scope**: Typically used within a single process, but can be extended to inter-process synchronization.
- **Use Cases**:
  - Protecting shared data structures (e.g., a counter for task IDs).
  - Synchronizing access to shared resources like files or network connections.
- **Challenges**:
  - **Deadlocks**: Occur if threads lock multiple mutexes in conflicting orders.
  - **Performance Overhead**: Locking/unlocking can slow down execution if overused.
  - **Starvation**: A thread may wait indefinitely if others keep acquiring the mutex.
- **Contrast with Other Mechanisms**:
  - **Semaphore**: Allows a fixed number of threads to access a resource (not just one like a mutex).
  - **Read-Write Lock**: Allows multiple readers or one writer, unlike a mutex’s single access.

In backend development, mutexes are critical for ensuring thread-safe operations in applications like a TODO service, especially when multiple threads handle concurrent API requests or database updates, preventing data corruption or inconsistencies.

### What is a semaphore?

A **semaphore** is a synchronization mechanism used in concurrent programming to control access to a shared resource or coordinate multiple threads or processes. It maintains a counter that regulates how many threads can access a resource simultaneously, preventing race conditions and ensuring orderly execution.

**Key Points**:

- **Purpose**: Manages access to a limited number of resources or synchronizes tasks in concurrent environments.
- **How It Works**:
  - A semaphore is initialized with a non-negative integer (the counter), representing the number of available resources or allowed concurrent accesses.
  - Threads perform two primary operations:
    - **Acquire/Wait (P)**: Decrements the counter if positive; if zero, the thread waits (blocks) until the counter is incremented.
    - **Release/Signal (V)**: Increments the counter, allowing waiting threads to proceed.
- **Types**:
  - **Binary Semaphore**: Counter is 0 or 1, functioning like a mutex (single access).
  - **Counting Semaphore**: Counter can be any non-negative integer, allowing multiple threads to access a resource pool (e.g., 5 database connections).
- **Example**: In a TODO service:
  - A server has a pool of 5 database connections shared by multiple threads handling `POST /v1/tasks` requests.
  - A semaphore with a count of 5 ensures only 5 threads can access a connection at a time.
  - Pseudocode:
    ```pseudo title="pseudo"
    semaphore.acquire()  // Wait if no connections available
    try {
        database.insert(new_task)
    } finally {
        semaphore.release()  // Return connection to pool
    }
    ```
- **Use Cases**:
  - Limiting concurrent access to a resource (e.g., database connections, file handles).
  - Coordinating task execution (e.g., ensuring a task processor waits for data to be ready).
- **Advantages**:
  - Flexible for controlling multiple resource accesses (unlike a mutex, which allows only one).
  - Supports resource pools and task synchronization.
- **Challenges**:
  - **Deadlocks**: Possible if semaphores are mismanaged (e.g., acquiring without releasing).
  - **Complexity**: Requires careful design to avoid starvation or priority inversion.
  - **Overhead**: Managing the counter adds slight performance cost.
- **Contrast with Mutex**:
  - **Mutex**: Locks a single resource for exclusive access by one thread.
  - **Semaphore**: Controls access to multiple resources or allows multiple threads (if counter > 1).

In backend development, semaphores are crucial for managing concurrent access to limited resources in applications like a TODO service, ensuring efficient and safe handling of API requests or database operations in high-traffic scenarios.

### What is deadlock?

A **deadlock** is a situation in concurrent programming where two or more threads or processes are unable to proceed because each is waiting for a resource that another holds, creating a cycle of dependencies that prevents progress.

**Key Points**:

- **Definition**: A state where threads/processes are stuck, each holding a resource and waiting for another resource that is held by another thread/process in the group.
- **Conditions for Deadlock** (Coffman Conditions):
  - **Mutual Exclusion**: Resources involved are held in a non-shareable mode (e.g., a mutex or lock).
  - **Hold and Wait**: A thread holding a resource is waiting to acquire another resource.
  - **No Preemption**: Resources cannot be forcibly taken from a thread; they must be released voluntarily.
  - **Circular Wait**: A cycle exists where each thread waits for a resource held by the next thread.
- **Example**: In a TODO service:
  - Thread 1 locks the `tasks` table to update a task and waits to lock the `users` table.
  - Thread 2 locks the `users` table to update a user and waits to lock the `tasks` table.
  - Result: Thread 1 waits for Thread 2 to release `users`, and Thread 2 waits for Thread 1 to release `tasks`, causing a deadlock.
  - Pseudocode:
    ```pseudo title="pseudo"
    Thread 1:
        lock(tasks_table)
        lock(users_table)  // Waits for Thread 2
    Thread 2:
        lock(users_table)
        lock(tasks_table)  // Waits for Thread 1
    ```
- **Impact**:
  - System hangs or becomes unresponsive.
  - Degraded performance or complete failure of affected operations (e.g., API requests stall).
- **Prevention**:
  - **Avoid Circular Wait**: Enforce a consistent order for acquiring locks (e.g., always lock `tasks` before `users`).
  - **Timeouts**: Set a timeout for acquiring resources, releasing locks if the wait is too long.
  - **Resource Preemption**: Allow the system to forcibly release resources (though complex).
  - **Deadlock Detection**: Monitor for cycles and resolve them (e.g., terminate a thread).
  - **Use Higher-Level Constructs**: Use database transactions or frameworks that manage concurrency.
- **Resolution**:
  - Terminate one or more threads/processes.
  - Roll back transactions in databases.
  - Restart the affected system components.
- **Use Case**: In a TODO service, deadlocks can occur when multiple threads handle concurrent `POST /v1/tasks` and `PUT /v1/users` requests that lock shared database tables.

In backend development, preventing and detecting deadlocks is critical for ensuring reliable and responsive systems like a TODO service API, especially when handling concurrent database operations or shared resources.

### What is race condition?

A **race condition** is a situation in concurrent programming where the outcome of a program depends on the unpredictable order or timing of execution of multiple threads or processes accessing shared resources without proper synchronization. This can lead to inconsistent or incorrect results, such as data corruption or unexpected behavior.

**Key Points**:

- **Definition**: Occurs when two or more threads/processes access a shared resource (e.g., memory, database, file) concurrently, and at least one performs a write operation, causing the result to depend on which thread executes first.
- **Cause**: Lack of proper synchronization mechanisms (e.g., mutexes, locks) when accessing shared resources.
- **Example**: In a TODO service:
  - Two threads handle `POST /v1/tasks` requests to increment a shared `task_counter` (e.g., to assign a new task ID).
  - Without synchronization:
    - Thread 1 reads `task_counter = 100`, intends to set it to 101.
    - Thread 2 reads `task_counter = 100`, intends to set it to 101.
    - Both threads write `101`, resulting in only one increment instead of two, causing a task ID collision.
  - Pseudocode (vulnerable):
    ```pseudo title="pseudo"
    task_counter = read_counter()  // Both threads read 100
    task_counter += 1              // Both increment to 101
    write_counter(task_counter)    // Both write 101, losing one increment
    ```
- **Impact**:
  - Data corruption (e.g., duplicate task IDs).
  - Inconsistent application state (e.g., incorrect task counts).
  - Unpredictable behavior or crashes.
- **Prevention**:
  - **Mutexes/Locks**: Use mutual exclusion to ensure only one thread accesses the resource at a time (e.g., lock `task_counter` during increment).
  - **Atomic Operations**: Use atomic instructions (e.g., `compare-and-swap`) to update shared variables safely.
  - **Semaphores**: Control access to shared resources.
  - **Database Transactions**: Use transactions with proper isolation levels to ensure consistent updates.
  - **Avoid Shared State**: Design systems to minimize shared resources (e.g., use message queues).
- **Example Fix** (using a mutex):
  ```pseudo title="pseudo"
  mutex.lock()
  try {
      task_counter = read_counter()
      task_counter += 1
      write_counter(task_counter)
  } finally {
      mutex.unlock()
  }
  ```
- **Use Case**: In a TODO service, race conditions can occur when multiple API requests concurrently update shared resources like task counters, user balances, or task statuses.

In backend development, preventing race conditions is critical for ensuring data integrity and reliability in applications like a TODO service, especially in high-concurrency environments with multiple API requests or database operations.

### What is synchronization?

**Synchronization** in concurrent programming is the coordination of multiple threads or processes to ensure orderly access to shared resources, preventing issues like race conditions, data inconsistencies, or deadlocks. It ensures that operations on shared data are executed in a controlled and predictable manner.

**Key Points**:

- **Purpose**: Guarantees that only one thread/process (or a controlled number) accesses a shared resource at a time, maintaining data integrity and consistency.
- **How It Works**: Uses mechanisms to control access, coordinate execution, or signal events between threads/processes.
- **Common Synchronization Mechanisms**:
  - **Mutex (Mutual Exclusion)**: Locks a resource so only one thread can access it at a time (e.g., preventing concurrent writes to a task counter).
  - **Semaphore**: Controls access to a resource pool, allowing a set number of threads to proceed (e.g., limiting database connections).
  - **Monitors**: Combine mutexes with condition variables to manage access and wait/notify mechanisms.
  - **Read-Write Locks**: Allow multiple readers or one writer to access a resource concurrently.
  - **Condition Variables**: Enable threads to wait for specific conditions (e.g., a task queue is non-empty).
  - **Atomic Operations**: Perform single, indivisible operations (e.g., incrementing a counter) without locks.
- **Example**: In a TODO service:
  - Multiple threads handle `POST /v1/tasks` requests that increment a shared `task_id` counter.
  - A mutex ensures only one thread increments the counter at a time:
    ```pseudo title="pseudo"
    mutex.lock()
    try {
        task_id = read_counter()
        task_id += 1
        write_counter(task_id)
    } finally {
        mutex.unlock()
    }
    ```
  - This prevents a race condition where two threads might assign the same `task_id`.
- **Use Cases**:
  - Ensuring thread-safe database updates (e.g., adding tasks in a TODO service).
  - Coordinating access to shared memory, files, or network resources.
  - Managing task dependencies (e.g., waiting for a background job to complete).
- **Benefits**:
  - Prevents race conditions and data corruption.
  - Ensures consistent application state.
  - Enables safe concurrent execution.
- **Challenges**:
  - **Overhead**: Synchronization mechanisms (e.g., locks) can slow down performance.
  - **Deadlocks**: Improper use can cause threads to wait indefinitely.
  - **Complexity**: Designing correct synchronization logic is error-prone.
- **Contrast with Asynchrony**:
  - **Synchronization**: Threads/processes coordinate explicitly, often blocking until conditions are met.
  - **Asynchrony**: Tasks proceed independently, often using callbacks or events to handle completion.

In backend development, synchronization is critical for applications like a TODO service to manage concurrent API requests or database operations, ensuring data integrity and reliable performance in multi-threaded or distributed environments.

## APIs and Services

### What is REST?

**REST** (Representational State Transfer) is an architectural style for designing networked applications, particularly web APIs, that emphasizes simplicity, scalability, and statelessness. It uses standard web protocols (primarily HTTP) to enable communication between clients and servers, treating resources as the central concept.

**Key Points**:

- **Core Principles**:
  - **Stateless**: Each request from a client to a server must contain all the information needed to process it, without relying on stored server-side state.
  - **Client-Server**: Separates the client (e.g., a browser or app) from the server, allowing independent evolution of each.
  - **Resources**: Data or services are represented as resources, identified by URLs (e.g., `/tasks` for a list of tasks).
  - **Standard HTTP Methods**: Uses methods like:
    - `GET`: Retrieve a resource (e.g., `GET /v1/tasks` to list tasks).
    - `POST`: Create a resource (e.g., `POST /v1/tasks` to add a task).
    - `PUT`/`PATCH`: Update a resource (e.g., `PUT /v1/tasks/123` to modify a task).
    - `DELETE`: Remove a resource (e.g., `DELETE /v1/tasks/123` to delete a task).
  - **Uniform Interface**: Standard conventions for accessing resources (e.g., consistent URLs, HTTP status codes).
  - **Cacheable**: Responses can be cached to improve performance.
  - **Layered System**: Allows intermediaries (e.g., proxies, load balancers) without affecting client-server interaction.
- **Example**: In a TODO service:
  - `GET https://api.todo-service.com/v1/tasks` retrieves a list of tasks.
  - `POST https://api.todo-service.com/v1/tasks` with a JSON payload creates a new task.
  - Response format is typically JSON (e.g., `{"id": 123, "title": "Buy groceries", "status": "pending"}`).
- **Benefits**:
  - Scalable due to statelessness and caching.
  - Simple to implement and understand.
  - Compatible with web standards (HTTP, URLs).
- **Challenges**:
  - Statelessness may require more data in requests.
  - Over-fetching/under-fetching data (addressed by GraphQL in some cases).

In backend development, REST is widely used for building APIs (like a TODO service) due to its simplicity and alignment with HTTP, enabling clients to interact with server resources efficiently and predictably.

### What is SOAP?

**SOAP** (Simple Object Access Protocol) is a protocol for exchanging structured information in the implementation of web services, typically using XML over HTTP or other transport protocols. It is designed for robust, standardized communication between clients and servers, emphasizing strict specifications and security.

**Key Points**:

- **Purpose**: Enables structured data exchange for web services, often in enterprise applications requiring high reliability and security.
- **How It Works**:
  - Uses XML-based messages to send requests and responses.
  - Operates over protocols like HTTP, SMTP, or TCP, but most commonly HTTP.
  - Messages consist of an **envelope** (root element), **header** (optional metadata), and **body** (actual data or request).
  - Relies on a **WSDL** (Web Services Description Language) file to define the service’s structure and operations.
- **Key Features**:
  - **Strict Standards**: Follows a rigid, standardized format with defined rules for message structure.
  - **Extensibility**: Supports advanced features like security (WS-Security) and transactions.
  - **Protocol Independence**: Not tied to HTTP; can use other protocols.
  - **Built-in Error Handling**: Uses fault elements in XML for standardized error reporting.
- **Example**: In a TODO service:
  - A SOAP request to create a task might look like:
    ```xml title="xml"
    <soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
      <soap:Body>
        <CreateTask xmlns="http://todo-service.com">
          <title>Buy groceries</title>
          <status>pending</status>
        </CreateTask>
      </soap:Body>
    </soap:Envelope>
    ```
  - The server responds with a structured XML response containing the task ID or error details.
- **Contrast with REST**:
  - **SOAP**: Uses XML, strict protocol, stateful or stateless, complex (WSDL, WS-Security).
  - **REST**: Uses JSON or XML, lightweight, stateless, simpler, leverages HTTP methods (GET, POST, etc.).
- **Benefits**:
  - Robust for enterprise systems with strict requirements (e.g., banking, healthcare).
  - Strong security and transaction support.
  - Platform and language agnostic.
- **Challenges**:
  - Complex due to XML and WSDL overhead.
  - Slower performance compared to REST due to verbose messages.
  - Less flexible for rapid development or lightweight APIs.
- **Use Cases**: Common in enterprise systems (e.g., financial services, CRM systems) where formal contracts and security are critical, unlike REST’s popularity in simpler web APIs like a TODO service.

In backend development, SOAP is used when a TODO service requires strict standards, advanced security, or integration with legacy enterprise systems, though REST is often preferred for simplicity and performance.

### What is JSON?

**JSON** (JavaScript Object Notation) is a lightweight, text-based data format used for structuring and exchanging data between systems, particularly in web applications and APIs. It is easy to read, write, and parse, making it widely used for client-server communication.

**Key Points**:

- **Purpose**: Represents structured data in a platform-independent way, ideal for API payloads and configuration files.
- **Structure**:
  - **Objects**: Key-value pairs enclosed in curly braces `{}` (e.g., `{"key": "value"}`).
  - **Arrays**: Ordered lists enclosed in square brackets `[]` (e.g., `["item1", "item2"]`).
  - **Data Types**: Supports strings, numbers, booleans, null, objects, and arrays.
- **Syntax**:
  ```json title="json"
  {
    "id": 1,
    "title": "Buy groceries",
    "status": "pending",
    "tags": ["urgent", "personal"],
    "completed": false,
    "details": null
  }
  ```
- **Example**: In a TODO service:
  - A `GET /v1/tasks` API request returns:
    ```json title="json"
    [
      { "id": 1, "title": "Buy groceries", "status": "pending" },
      { "id": 2, "title": "Finish report", "status": "completed" }
    ]
    ```
  - A `POST /v1/tasks` request sends:
    ```json
    { "title": "New task", "status": "pending" }
    ```
- **Benefits**:
  - Human-readable and concise.
  - Widely supported across programming languages (e.g., JavaScript, Python, Java).
  - Efficient for web APIs (smaller payloads compared to XML).
- **Contrast with XML**:
  - JSON is lighter and simpler; XML is more verbose but supports more complex structures.
- **Use Cases**:
  - API responses and requests (e.g., RESTful APIs in a TODO service).
  - Configuration files (e.g., `package.json` in Node.js).
  - Data storage in NoSQL databases like MongoDB.

In backend development, JSON is the standard format for data exchange in APIs like a TODO service, enabling efficient and interoperable communication between clients and servers.

### What is XML?

**XML** (Extensible Markup Language) is a flexible, text-based data format used to structure, store, and transport data between systems, particularly in web applications and services. It uses custom tags to define data and its hierarchy, making it highly customizable and widely used for data interchange.

**Key Points**:

- **Purpose**: Represents structured data in a platform-independent, human-readable format, suitable for complex data structures and web services.
- **Structure**:
  - Consists of nested elements defined by custom tags, enclosed in angle brackets `< >`.
  - Elements have a start tag (e.g., `<task>`), content, and an end tag (e.g., `</task>`).
  - Supports attributes within tags (e.g., `<task id="1">`).
  - Must have a single root element containing all other elements.
- **Syntax**:
  ```xml title="xml"
  <tasks>
    <task id="1">
      <title>Buy groceries</title>
      <status>pending</status>
    </task>
    <task id="2">
      <title>Finish report</title>
      <status>completed</status>
    </task>
  </tasks>
  ```
- **Example**: In a TODO service:
  - A `GET /v1/tasks` API response in XML:
    ```xml title="xml"
    <response>
      <tasks>
        <task id="1">
          <title>Buy groceries</title>
          <status>pending</status>
        </task>
      </tasks>
    </response>
    ```
  - A `POST /v1/tasks` request:
    ```xml title="xml"
    <task>
      <title>New task</title>
      <status>pending</status>
    </task>
    ```
- **Benefits**:
  - Highly structured and extensible (custom tags for specific needs).
  - Supports complex data with metadata (e.g., attributes, namespaces).
  - Widely used in enterprise systems (e.g., SOAP web services, configuration files).
- **Challenges**:
  - More verbose than JSON, leading to larger payloads and slower parsing.
  - Complex to read/write compared to JSON’s simplicity.
- **Contrast with JSON**:
  - **JSON**: Lightweight, concise, ideal for APIs, uses key-value pairs and arrays.
  - **XML**: More verbose, supports richer metadata (attributes, schemas), common in legacy or enterprise systems.
- **Use Cases**:
  - Data exchange in SOAP-based web services.
  - Configuration files (e.g., Maven’s `pom.xml`).
  - Document storage (e.g., XHTML, RSS feeds).

In backend development, XML is used in applications like a TODO service for structured data exchange, particularly in legacy systems or SOAP APIs, though JSON is often preferred for modern REST APIs due to its simplicity and efficiency.

### What is a web service?

A **web service** is a software system designed to enable machine-to-machine communication over a network, typically the internet, using standardized protocols like HTTP. It provides a way for applications to interact with each other by exposing functionalities or data through a defined interface, often in a platform-independent manner.

**Key Points**:

- **Purpose**: Allows different applications, systems, or devices to exchange data or perform operations remotely, such as retrieving or updating information.
- **How It Works**:
  - Operates over web protocols (e.g., HTTP, HTTPS) and often uses formats like JSON or XML for data exchange.
  - Typically accessed via APIs (Application Programming Interfaces) with endpoints (e.g., `https://api.todo-service.com/v1/tasks`).
- **Types**:
  - **RESTful Web Services**: Use REST architecture, leveraging HTTP methods (GET, POST, PUT, DELETE) for operations, often returning JSON (e.g., a TODO service API).
  - **SOAP Web Services**: Use XML-based messages with strict standards, often with WSDL for service description, common in enterprise systems.
  - **GraphQL Web Services**: Allow clients to request specific data structures, reducing over- or under-fetching.
- **Example**: In a TODO service:
  - A web service exposes endpoints like `GET /v1/tasks` to retrieve tasks or `POST /v1/tasks` to create a task.
  - A client (e.g., a mobile app) sends a request to the server, which processes it and returns a response (e.g., JSON with task data).
- **Characteristics**:
  - **Interoperability**: Works across different platforms and languages (e.g., a Java server can serve a Python client).
  - **Stateless** (in REST): Each request contains all necessary information, no server-side state is maintained between requests.
  - **Scalable**: Can handle multiple clients through distributed architectures.
- **Use Cases**:
  - APIs for mobile or web apps (e.g., a TODO app accessing task data).
  - Integration between systems (e.g., connecting a TODO service to a calendar app).
  - Enterprise services (e.g., financial or CRM systems using SOAP).
- **Benefits**:
  - Enables modular, distributed systems.
  - Simplifies integration across diverse applications.
  - Supports scalability and cross-platform communication.
- **Challenges**:
  - Security concerns (e.g., requires HTTPS, authentication).
  - Performance overhead for complex protocols like SOAP.
  - Need for robust error handling and versioning.

In backend development, web services are critical for building APIs like those in a TODO service, enabling clients to interact with server-side data and functionality efficiently and securely.

### What is microservices?

**Microservices** is an architectural style for developing applications as a collection of small, independent services that each perform a specific function and communicate over a network, typically using APIs. Each service is designed to be loosely coupled, independently deployable, and focused on a single business capability.

**Key Points**:

- **Purpose**: Enhances modularity, scalability, and maintainability by breaking down complex applications into smaller, manageable components.
- **How It Works**:
  - Each microservice runs as a separate process, handling a specific task (e.g., user authentication, task management).
  - Services communicate via lightweight protocols like HTTP/REST, gRPC, or message queues (e.g., Kafka).
  - Each service can use its own database, technology stack, or programming language.
- **Example**: In a TODO service:
  - **Task Service**: Handles CRUD operations for tasks (`GET /v1/tasks`, `POST /v1/tasks`).
  - **User Service**: Manages user authentication and profiles (`POST /v1/users/login`).
  - **Notification Service**: Sends reminders for tasks (e.g., via email or push notifications).
  - Each service is deployed independently and communicates via APIs.
- **Characteristics**:
  - **Single Responsibility**: Each service focuses on one function (e.g., task creation, user management).
  - **Independence**: Services can be developed, deployed, and scaled separately.
  - **Decentralized Data**: Each service may have its own database to avoid tight coupling.
  - **Interoperability**: Uses standard protocols (e.g., REST, JSON) for communication.
- **Benefits**:
  - **Scalability**: Scale individual services (e.g., scale only the task service during high traffic).
  - **Flexibility**: Different services can use different technologies (e.g., Python for one, Node.js for another).
  - **Resilience**: Failure in one service (e.g., notifications) doesn’t crash the entire system.
  - **Faster Development**: Teams can work on different services concurrently.
- **Challenges**:
  - **Complexity**: Managing multiple services increases operational overhead (e.g., monitoring, deployment).
  - **Data Consistency**: Distributed data can lead to eventual consistency issues.
  - **Communication Overhead**: Network calls between services can introduce latency.
  - **Debugging**: Harder to trace issues across distributed systems.
- **Contrast with Monolithic Architecture**:
  - **Monolithic**: A single, unified application where all components (e.g., UI, business logic, database) are tightly coupled and deployed together.
  - **Microservices**: Splits the application into independent services, allowing modular development and deployment.
- **Technologies**: Often implemented with tools like Docker (containerization), Kubernetes (orchestration), and APIs (REST, gRPC).

In backend development, microservices are ideal for building scalable, flexible applications like a TODO service, where separate services handle tasks, users, or notifications, but they require careful design to manage complexity and ensure reliable communication.

### What is monolithic architecture?

**Monolithic architecture** is a traditional software design approach where an entire application is built as a single, unified unit, with all components—such as the user interface, business logic, and data access layer—tightly coupled and deployed together as one executable or process.

**Key Points**:

- **Purpose**: Simplifies development, testing, and deployment by keeping all functionality in a single codebase, suitable for smaller or less complex applications.
- **How It Works**:
  - All components (e.g., API endpoints, database access, authentication logic) are integrated into one application.
  - The application runs as a single process, sharing the same memory and resources.
  - Changes or updates require rebuilding and redeploying the entire application.
- **Example**: In a TODO service:
  - A monolithic application includes:
    - API endpoints (`GET /v1/tasks`, `POST /v1/tasks`).
    - Business logic for task management.
    - Database access (e.g., querying a `tasks` table).
    - User authentication (e.g., login validation).
  - All are part of one codebase (e.g., a single Node.js or Java application) and deployed as one unit.
- **Characteristics**:
  - **Tight Coupling**: Components are interdependent, sharing the same codebase and resources.
  - **Single Deployment**: The entire application is deployed as one unit.
  - **Shared Database**: Typically uses a single database for all functionality.
- **Benefits**:
  - **Simplicity**: Easier to develop, test, and debug for smaller applications due to a unified codebase.
  - **Unified Deployment**: Single deployment process simplifies initial setup.
  - **Performance**: No network overhead for communication between components (unlike microservices).
- **Challenges**:
  - **Scalability Limits**: Scaling requires replicating the entire application, which can be resource-intensive.
  - **Complexity with Growth**: Large codebases become hard to maintain as features grow.
  - **Tight Coupling**: Changes in one component (e.g., authentication) can break others.
  - **Technology Lock-In**: Difficult to adopt new technologies for specific components.
  - **Single Point of Failure**: A bug or crash can affect the entire application.
- **Contrast with Microservices**:
  - **Monolithic**: Single codebase, tightly coupled, deployed as one unit.
  - **Microservices**: Multiple independent services, loosely coupled, deployed separately.
- **Use Cases**:
  - Small to medium-sized applications (e.g., a basic TODO service with limited features).
  - Early-stage projects where simplicity and speed of development are priorities.

In backend development, a monolithic architecture is suitable for a straightforward TODO service with limited complexity, but it may become challenging to scale or maintain as the application grows compared to a microservices approach.

### What is an HTTP status code?

An **HTTP status code** is a three-digit number returned by a server in response to a client's HTTP request, indicating the outcome of the request. It provides information about whether the request was successful, failed, or requires further action, helping clients (e.g., browsers, apps) understand the result of their interaction with the server.

**Key Points**:

- **Purpose**: Communicates the result of an HTTP request (e.g., success, error, redirection) in a standardized way.
- **Categories** (based on the first digit):
  - **1xx (Informational)**: Request received, processing continues (e.g., 100 Continue).
  - **2xx (Success)**: Request successfully processed (e.g., 200 OK).
  - **3xx (Redirection)**: Further action needed, often a redirect (e.g., 301 Moved Permanently).
  - **4xx (Client Error)**: Client-side issue (e.g., 404 Not Found).
  - **5xx (Server Error)**: Server-side issue (e.g., 500 Internal Server Error).
- **Common Examples**:
  - **200 OK**: Request succeeded (e.g., `GET /v1/tasks` returns task list).
  - **201 Created**: Resource created (e.g., `POST /v1/tasks` adds a new task).
  - **400 Bad Request**: Invalid request syntax or parameters.
  - **401 Unauthorized**: Authentication required or failed.
  - **403 Forbidden**: Client lacks permission to access the resource.
  - **404 Not Found**: Resource not found (e.g., `GET /v1/tasks/999` for a nonexistent task).
  - **500 Internal Server Error**: Generic server failure (e.g., database crash).
- **Example**: In a TODO service:
  - `GET https://api.todo-service.com/v1/tasks` returns `200 OK` with a JSON list of tasks.
  - `POST https://api.todo-service.com/v1/tasks` with invalid data returns `400 Bad Request`.
  - `DELETE https://api.todo-service.com/v1/tasks/999` for a nonexistent task returns `404 Not Found`.
- **Usage**: Included in the HTTP response header (e.g., `Status: 200 OK`) and often accompanied by a response body (e.g., JSON with details or error messages).

In backend development, HTTP status codes are critical for building robust APIs (like a TODO service), enabling clear communication of request outcomes and guiding client behavior (e.g., retrying, redirecting, or displaying errors).

### What is GET method?

The **GET method** is an HTTP method used to request and retrieve data from a specified resource on a server. It is one of the most common methods in the HTTP protocol, primarily used for fetching resources without modifying them.

**Key Points**:

- **Purpose**: Retrieves data from the server (e.g., a webpage, API data, or file) without altering the server’s state (idempotent and safe).
- **How It Works**:
  - The client sends a GET request to a specific URL (endpoint).
  - The server processes the request and returns the requested resource, typically in formats like JSON, XML, or HTML, along with an HTTP status code (e.g., 200 OK).
- **Characteristics**:
  - **Idempotent**: Multiple identical GET requests produce the same result (no side effects).
  - **Cacheable**: Responses can be cached to improve performance.
  - **Query Parameters**: Data can be sent via URL query strings (e.g., `?id=123&status=pending`).
- **Example**: In a TODO service:
  - Request: `GET https://api.todo-service.com/v1/tasks`
    - Retrieves a list of all tasks for the authenticated user.
    - Response (JSON):
      ```json title="JSON Response"
      [
        { "id": 1, "title": "Buy groceries", "status": "pending" },
        { "id": 2, "title": "Finish report", "status": "completed" }
      ]
      ```
  - Request: `GET https://api.todo-service.com/v1/tasks/123`
    - Retrieves details of task with ID 123.
- **Use Cases**:
  - Fetching data from APIs (e.g., task lists, user profiles).
  - Loading webpages or static content in browsers.
  - Querying resources with filters (e.g., `GET /v1/tasks?status=pending`).
- **Limitations**:
  - Data is sent in the URL, which has length limits and is visible in logs or browser history.
  - Not suitable for sensitive data (use POST for secure data transmission).
  - Should not modify server state (use POST, PUT, or DELETE for state changes).

In backend development, the GET method is fundamental for building RESTful APIs, like those in a TODO service, to allow clients to retrieve task data efficiently and safely.

### What is POST method?

The **POST method** is an HTTP method used to send data to a server to create or update a resource. It is commonly used in web applications and APIs to submit data, such as form inputs or API payloads, to the server for processing.

**Key Points**:

- **Purpose**: Sends data to the server to create a new resource or perform an action, often modifying the server’s state (non-idempotent).
- **How It Works**:
  - The client sends a POST request to a specific URL (endpoint) with data in the request body, typically in formats like JSON or form-data.
  - The server processes the data (e.g., stores it in a database) and returns a response, often with an HTTP status code (e.g., 201 Created) and a confirmation.
- **Characteristics**:
  - **Non-Idempotent**: Multiple identical POST requests may create multiple resources (e.g., duplicate tasks).
  - **Not Cacheable**: Responses are typically not cached due to their dynamic nature.
  - **Data in Body**: Data is sent in the request body, not the URL, making it suitable for sensitive or large data.
- **Example**: In a TODO service:
  - Request: `POST https://api.todo-service.com/v1/tasks`
    - Request Body (JSON):
      ```json title="JSON Request Body"
      {
        "title": "Buy groceries",
        "status": "pending",
        "due_date": "2025-10-01"
      }
      ```
    - Creates a new task in the database.
    - Response (JSON, status 201 Created):
      ```json title="JSON Response"
      {
        "id": 123,
        "title": "Buy groceries",
        "status": "pending",
        "due_date": "2025-10-01"
      }
      ```
- **Use Cases**:
  - Creating new resources (e.g., adding a task or user in a TODO service).
  - Submitting forms (e.g., user registration).
  - Triggering actions (e.g., sending a notification).
- **Contrast with GET**:
  - **GET**: Retrieves data, safe, idempotent, data in URL query parameters.
  - **POST**: Sends data to create/update, non-idempotent, data in request body.
- **Security**: Suitable for sensitive data (e.g., passwords) since the payload is not exposed in the URL (unlike GET).

In backend development, the POST method is essential for building RESTful APIs, like those in a TODO service, to enable clients to create new tasks or submit data securely and reliably.

## Miscellaneous

### What is version control?

**Version control** is a system that tracks and manages changes to files, typically source code, documents, or other digital content, allowing multiple users to collaborate, maintain history, and revert to previous versions if needed. It is essential for software development and managing changes in a structured way.

**Key Points**:

- **Purpose**: Enables tracking of file modifications, collaboration among multiple contributors, and recovery from errors by maintaining a history of changes.
- **How It Works**:
  - Stores a repository of files and their revision history.
  - Tracks changes (e.g., additions, deletions, modifications) as commits, each with a unique identifier, timestamp, and author.
  - Supports branching and merging to manage parallel development.
- **Types**:
  - **Centralized Version Control**: Single central repository (e.g., SVN).
  - **Distributed Version Control**: Each user has a full copy of the repository (e.g., Git).
- **Example**: In a TODO service:
  - Developers use version control (e.g., Git) to manage the codebase for the API (`https://api.todo-service.com/v1/tasks`).
  - A commit might add a new endpoint (`POST /v1/tasks`), with the history showing who added it and when.
  - If a bug is introduced, developers can revert to a previous version.
- **Key Features**:
  - **Commits**: Snapshots of changes with messages describing the updates.
  - **Branches**: Parallel versions of the codebase for features or fixes.
  - **Merging**: Combines changes from different branches.
  - **Conflict Resolution**: Handles overlapping changes from multiple contributors.
- **Benefits**:
  - Collaboration: Multiple developers can work on the same project simultaneously.
  - History: Tracks all changes, enabling rollbacks or audits.
  - Backup: Prevents loss of work by storing versions.
  - Experimentation: Branches allow testing new features without affecting the main codebase.
- **Tools**: Common systems include Git, Subversion (SVN), Mercurial, and platforms like GitHub, GitLab, or Bitbucket.
- **Use Case**: In a TODO service, version control tracks changes to API code, database schemas, or configuration files, ensuring team collaboration and the ability to revert faulty updates.

In backend development, version control is critical for managing the development of applications like a TODO service, enabling efficient collaboration, error recovery, and codebase evolution.

### What is Git?

**Git** is a distributed version control system used to track changes in source code or other files, enabling multiple developers to collaborate on a project efficiently. It allows users to manage file versions, coordinate work, and maintain a history of changes in a repository.

**Key Points**:

- **Purpose**: Tracks file modifications, supports collaboration, and enables reverting to previous versions, branching, and merging for parallel development.
- **How It Works**:
  - Stores a repository (repo) containing files and their change history.
  - Each change is recorded as a **commit** with a unique ID, message, and author.
  - Users can work on local copies of the repo and synchronize changes with a remote repository (e.g., on GitHub, GitLab).
- **Key Features**:
  - **Distributed**: Every user has a complete local copy of the repository, enabling offline work and redundancy.
  - **Commits**: Snapshots of changes (e.g., adding a new API endpoint).
  - **Branches**: Parallel versions of the codebase for features or fixes (e.g., `feature/add-task-endpoint`).
  - **Merging**: Combines changes from different branches.
  - **Conflict Resolution**: Handles overlapping changes when merging.
  - **Staging Area**: Allows selective inclusion of changes in a commit.
- **Example**: In a TODO service:
  - A developer creates a branch to add a `POST /v1/tasks` endpoint.
  - They commit changes to the branch: `git commit -m "Add task creation endpoint"`.
  - The branch is merged into the main codebase after review, and pushed to a remote repo (e.g., `git push origin main`).
  - If a bug is found, they revert to a previous commit using `git revert`.
- **Benefits**:
  - Enables team collaboration without overwriting work.
  - Tracks history for auditing or debugging.
  - Supports experimentation via branches without risking the main codebase.
  - Integrates with platforms like GitHub for code reviews and CI/CD.
- **Common Commands**:
  - `git init`: Initialize a new repository.
  - `git add`: Stage changes for commit.
  - `git commit`: Save changes to the repo.
  - `git branch`: Manage branches.
  - `git merge`: Combine branches.
  - `git push/pull`: Sync with remote repositories.
- **Contrast with Other VCS**:
  - Unlike centralized systems (e.g., SVN), Git’s distributed nature allows offline work and faster operations.

In backend development, Git is essential for managing the codebase of applications like a TODO service, enabling developers to track changes, collaborate on API development, and maintain a reliable history of updates.

### What is logging?

**Logging** is the process of recording events, activities, or errors that occur during the execution of a software application or system. In backend development, logs capture critical information about the system's behavior, aiding in debugging, monitoring, performance analysis, and auditing.

**Key Points**:

- **Purpose**: Tracks what happens in an application (e.g., API requests, errors, or system events) to diagnose issues, monitor performance, or ensure security compliance.
- **How It Works**:
  - The application generates log messages with details like timestamps, event types, and contextual data.
  - Logs are stored in files, databases, or external systems (e.g., log aggregators like ELK Stack or CloudWatch).
  - Logs can be categorized by severity (e.g., INFO, DEBUG, WARN, ERROR).
- **Example**: In a TODO service:
  - A log entry for a `POST /v1/tasks` request might be:
    ```
    2025-09-28 02:27:03 [INFO] UserID=123 created task: title="Buy groceries", status="pending"
    ```
  - An error log for a failed database query:
    ```
    2025-09-28 02:27:05 [ERROR] Database query failed: Connection timeout for task_id=456
    ```
- **Key Features**:
  - **Timestamps**: Record when an event occurred.
  - **Severity Levels**: Categorize logs (e.g., DEBUG for development, ERROR for critical issues).
  - **Context**: Include details like user ID, request ID, or endpoint.
  - **Structured Logging**: Use formats like JSON for easier parsing (e.g., `{"timestamp": "2025-09-28", "level": "INFO", "message": "Task created"}`).
- **Use Cases**:
  - **Debugging**: Identify why an API request failed (e.g., `GET /v1/tasks` returns 500).
  - **Monitoring**: Track system health or performance (e.g., request latency).
  - **Auditing**: Record user actions for security or compliance (e.g., who deleted a task).
  - **Analytics**: Analyze usage patterns (e.g., most frequent API calls).
- **Benefits**:
  - Simplifies troubleshooting and error resolution.
  - Provides insights into application behavior and performance.
  - Supports compliance with security or regulatory requirements.
- **Challenges**:
  - Log volume can overwhelm storage or analysis tools.
  - Sensitive data (e.g., passwords) must be sanitized to avoid exposure.
  - Requires proper configuration to balance detail and performance.
- **Tools**: Common logging tools include Log4j (Java), Winston (Node.js), Python’s `logging` module, and centralized systems like ELK Stack, Splunk, or Grafana Loki.

In backend development, logging is critical for a TODO service to monitor API operations (e.g., task creation, deletion), diagnose errors, and ensure system reliability, making it easier to maintain and debug the application.

### What is debugging?

**Debugging** is the process of identifying, analyzing, and resolving errors, bugs, or unexpected behavior in a software application or system. In backend development, it involves diagnosing issues in code, APIs, databases, or server configurations to ensure the application functions correctly.

**Key Points**:

- **Purpose**: To find and fix problems that cause incorrect output, crashes, or performance issues, improving the reliability and functionality of the system.
- **How It Works**:
  - Developers reproduce the issue, analyze logs or code, and trace the problem to its source.
  - Tools like debuggers, logs, or monitoring systems help inspect the application’s state.
  - Fixes are applied, tested, and verified to resolve the issue without introducing new problems.
- **Example**: In a TODO service:
  - Issue: A `GET /v1/tasks` request returns a 500 Internal Server Error.
  - Debugging steps:
    - Check server logs: `2025-09-28 02:30:03 [ERROR] Database query failed: Invalid column name 'task_status'`.
    - Identify the issue: The query references `task_status` instead of `status`.
    - Fix the query, test the endpoint, and confirm it returns 200 OK with task data.
- **Common Techniques**:
  - **Logging**: Review logs to identify errors or unexpected behavior (e.g., `ERROR: Null pointer exception`).
  - **Breakpoints**: Use a debugger to pause code execution and inspect variables (e.g., in Visual Studio Code or IntelliJ).
  - **Stack Traces**: Analyze call stacks to trace the origin of an error.
  - **Unit Testing**: Run tests to isolate faulty code.
  - **Profiling**: Monitor performance to find slow or resource-intensive code.
  - **Reproducing Issues**: Simulate the problem in a controlled environment.
- **Tools**:
  - Debuggers: Built into IDEs like VS Code, IntelliJ, or PyCharm.
  - Logging tools: ELK Stack, Splunk, or language-specific loggers (e.g., Python’s `logging`).
  - Monitoring: Prometheus, New Relic for real-time insights.
  - Browser Developer Tools: For debugging client-server interactions.
- **Benefits**:
  - Resolves bugs to ensure correct functionality (e.g., fixing a broken API endpoint).
  - Improves performance by identifying bottlenecks.
  - Enhances user experience by preventing crashes or errors.
- **Challenges**:
  - Complex bugs may be hard to reproduce or trace (e.g., race conditions in concurrent code).
  - Debugging in production requires caution to avoid downtime.
  - Time-intensive for obscure or intermittent issues.

In backend development, debugging is essential for maintaining a reliable TODO service, ensuring APIs (e.g., `POST /v1/tasks`) work as expected, and resolving issues like database errors, incorrect logic, or server crashes efficiently.

### What is an environment variable?

An **environment variable** is a key-value pair set outside an application, typically at the operating system level, used to configure or provide dynamic information to a running process without hardcoding values in the code. It allows applications to adapt to different environments (e.g., development, testing, production) securely and flexibly.

**Key Points**:

- **Purpose**: Stores configuration settings, sensitive data, or system-specific values (e.g., database credentials, API keys, or port numbers) accessible to an application.
- **How It Works**:
  - Defined in the operating system, shell, or runtime environment (e.g., `.env` files, Docker configurations).
  - Applications access environment variables at runtime using APIs provided by the programming language (e.g., `process.env` in Node.js).
- **Example**: In a TODO service:
  - Environment variable: `DATABASE_URL=postgres://user:pass@localhost:5432/todos`
  - The backend reads `DATABASE_URL` to connect to the database without embedding credentials in the codebase.
  - Code example (Node.js):
    ```javascript title="Node.js"
    const dbUrl = process.env.DATABASE_URL
    // Use dbUrl to connect to the database
    ```
- **Common Uses**:
  - **Configuration**: Set API endpoints, ports (e.g., `PORT=3000`), or database URLs.
  - **Security**: Store sensitive data like API keys or passwords outside the codebase.
  - **Environment-Specific Settings**: Adjust behavior for development, staging, or production (e.g., `NODE_ENV=production`).
- **Setting Environment Variables**:
  - **Shell**: `export API_KEY=xyz123` (Linux/Mac) or `set API_KEY=xyz123` (Windows).
  - **.env Files**: Use libraries like `dotenv` to load variables (e.g., `API_KEY=xyz123` in `.env`).
  - **Cloud Platforms**: Set via configuration in AWS, Azure, or Docker.
- **Benefits**:
  - **Security**: Keeps sensitive data out of source code, reducing exposure in version control.
  - **Flexibility**: Easily change settings without modifying code.
  - **Portability**: Supports different environments with minimal changes.
- **Challenges**:
  - Mismanagement can lead to missing or incorrect variables, causing runtime errors.
  - Requires secure handling to prevent leaks (e.g., don’t commit `.env` files to Git).

In backend development, environment variables are critical for configuring a TODO service API (e.g., `https://api.todo-service.com/v1/tasks`), enabling secure and flexible management of database connections, API keys, or server settings across different deployment environments.

### What is a configuration file?

A **configuration file** is a file used to store settings, parameters, or options that control the behavior of an application or system. It provides a way to configure software without modifying the source code, making it easier to adapt the application to different environments or requirements.

**Key Points**:

- **Purpose**: Defines settings like database connections, API keys, server ports, or feature flags to customize how an application runs.
- **How It Works**:
  - The application reads the configuration file at startup or runtime to apply the specified settings.
  - Stored in formats like JSON, YAML, XML, or INI, and often located in a predefined path (e.g., `/config/app.yml`).
- **Example**: In a TODO service:
  - A configuration file (`config.yml`) might contain:
    ```yaml title="config.yml"
    server:
      port: 3000
      host: api.todo-service.com
    database:
      url: postgres://user:pass@localhost:5432/todos
    api:
      key: xyz123
    environment: production
    ```
  - The backend reads this file to set up the server port, database connection, and API key for handling `GET /v1/tasks` requests.
- **Common Formats**:
  - **JSON**: `{"port": 3000, "database": {"url": "postgres://..."}}`
  - **YAML**: Structured, human-readable, often used in modern apps (e.g., Kubernetes configs).
  - **XML**: Verbose, common in legacy systems (e.g., Java’s `web.xml`).
  - **INI**: Simple key-value pairs (e.g., `[server] port=3000`).
- **Use Cases**:
  - Specify database credentials or URLs.
  - Configure server settings (e.g., port, hostname).
  - Store environment-specific settings (e.g., development vs. production).
  - Manage feature toggles or logging levels.
- **Benefits**:
  - **Flexibility**: Change settings without altering code.
  - **Reusability**: Use the same codebase across different environments.
  - **Maintainability**: Centralizes configuration for easy updates.
- **Challenges**:
  - **Security**: Sensitive data (e.g., API keys) must be protected (often moved to environment variables).
  - **Parsing Errors**: Incorrect syntax can cause application failures.
  - **Versioning**: Should not be committed to version control if they contain sensitive data.
- **Relation to Environment Variables**:
  - Configuration files store settings in a file, while environment variables are set at the OS level.
  - Often used together (e.g., a config file might reference environment variables for sensitive data).

In backend development, configuration files are essential for managing settings in applications like a TODO service, enabling the API (`https://api.todo-service.com/v1/tasks`) to adapt to different environments (e.g., development, production) while keeping sensitive data secure and configurations organized.

### What is deployment?

**Deployment** is the process of making a software application or system available for use by installing, configuring, and releasing it to a specific environment (e.g., production, staging, or development). In backend development, it involves setting up the application on a server or cloud platform so it can handle requests and serve users.

**Key Points**:

- **Purpose**: Transitions an application from development to a live environment where it can be accessed by users or clients.
- **How It Works**:
  - The application’s code, dependencies, and configuration are packaged and transferred to the target environment (e.g., a server, cloud, or container).
  - The server is configured to run the application (e.g., setting up web servers, databases, or environment variables).
  - The application is started, tested, and made accessible (e.g., via a URL like `https://api.todo-service.com`).
- **Example**: In a TODO service:
  - Deploying the API involves:
    - Packaging the backend code (e.g., Node.js app for `GET /v1/tasks`).
    - Uploading it to a cloud platform (e.g., AWS EC2, Heroku).
    - Configuring the server with environment variables (e.g., `DATABASE_URL`).
    - Starting the server to handle requests at `https://api.todo-service.com/v1/tasks`.
- **Types of Deployment**:
  - **Manual Deployment**: Copying files and configuring servers manually.
  - **Automated Deployment**: Using CI/CD pipelines (e.g., Jenkins, GitHub Actions) to automate building, testing, and releasing.
  - **Blue-Green Deployment**: Running two identical environments (blue and green) to switch traffic seamlessly for zero-downtime updates.
  - **Canary Deployment**: Releasing to a small subset of users first to test stability.
  - **Rolling Deployment**: Gradually updating servers to avoid downtime.
- **Steps**:
  - Build: Compile or package the application (e.g., create a Docker image).
  - Test: Run automated tests to ensure functionality.
  - Deploy: Transfer the application to the target environment.
  - Configure: Set up databases, environment variables, or load balancers.
  - Monitor: Verify the application runs correctly (e.g., using logs or monitoring tools).
- **Benefits**:
  - Makes the application accessible to users (e.g., API endpoints for a TODO service).
  - Enables updates and new features to be rolled out.
  - Supports scalability and reliability with proper deployment strategies.
- **Challenges**:
  - Downtime during deployment (mitigated by blue-green or rolling strategies).
  - Configuration errors (e.g., incorrect `DATABASE_URL`).
  - Compatibility issues between environments (e.g., dev vs. production).

In backend development, deployment is critical for making a TODO service API (e.g., `https://api.todo-service.com/v1/tasks`) available to users, ensuring it runs reliably in production with proper configuration and minimal downtime.

### What is hosting?

**Hosting** is the process of storing and serving an application, website, or service on a server or infrastructure, making it accessible over the internet or a network. In backend development, it involves providing the computational resources, storage, and network connectivity needed to run an application and handle client requests.

**Key Points**:

- **Purpose**: Enables applications (e.g., APIs, websites) to be available to users by running them on servers that are accessible via the internet.
- **How It Works**:
  - The application’s code, dependencies, and data are deployed to a hosting environment (e.g., a physical server, virtual machine, or cloud platform).
  - The hosting provider ensures the server is online, secure, and capable of handling requests.
  - Users access the application via a URL (e.g., `https://api.todo-service.com`).
- **Example**: In a TODO service:
  - The API (`GET /v1/tasks`) is hosted on a cloud platform like AWS EC2, Heroku, or Google Cloud.
  - The hosting environment includes:
    - A web server (e.g., Nginx, Node.js) to handle HTTP requests.
    - A database (e.g., PostgreSQL) for storing tasks.
    - Configuration for scaling, security, and networking.
- **Types of Hosting**:
  - **Shared Hosting**: Multiple applications share a single server (cost-effective but limited resources).
  - **VPS Hosting**: Virtual Private Server provides dedicated resources on a shared physical server.
  - **Dedicated Hosting**: A single physical server for one application (high performance, expensive).
  - **Cloud Hosting**: Scalable, distributed hosting on virtualized infrastructure (e.g., AWS, Azure, Google Cloud).
  - **Serverless Hosting**: Runs code in response to events without managing servers (e.g., AWS Lambda, Vercel).
- **Key Components**:
  - **Server**: Hardware or virtual machine running the application.
  - **Storage**: For application files, databases, or logs.
  - **Network**: DNS, IP addresses, and bandwidth for accessibility.
  - **Security**: Firewalls, SSL/TLS for HTTPS, and access controls.
- **Benefits**:
  - Ensures availability of the application (e.g., `https://api.todo-service.com/v1/tasks`).
  - Supports scalability through cloud or distributed hosting.
  - Simplifies maintenance with managed hosting services.
- **Challenges**:
  - Cost increases with resource demands or traffic.
  - Configuration errors can lead to downtime or security issues.
  - Requires monitoring to ensure uptime and performance.
- **Relation to Deployment**:
  - **Deployment**: The act of installing and configuring the application on the hosting environment.
  - **Hosting**: The ongoing provision of infrastructure to keep the application running and accessible.

In backend development, hosting is critical for running a TODO service API, ensuring that endpoints like `POST /v1/tasks` are available to users with reliable performance, scalability, and security.

### What is a domain name?

A **domain name** is a human-readable address used to identify and locate resources, such as websites or servers, on the internet. It serves as an easy-to-remember alias for an IP address, which is the numerical identifier of a device on a network.

**Key Points**:

- **Purpose**: Simplifies access to resources by replacing complex IP addresses (e.g., `192.168.1.1`) with memorable names (e.g., `todo-service.com`).
- **Structure**:
  - **Top-Level Domain (TLD)**: The rightmost part (e.g., `.com`, `.org`, `.net`).
  - **Second-Level Domain**: The main name (e.g., `todo-service` in `todo-service.com`).
  - **Subdomain** (optional): A prefix for specific services (e.g., `api` in `api.todo-service.com`).
- **How It Works**:
  - Domain names are resolved to IP addresses via the Domain Name System (DNS).
  - When a user enters `https://api.todo-service.com`, DNS translates it to an IP address (e.g., `93.184.216.34`) to connect to the server.
- **Example**: In a TODO service:
  - The domain name `api.todo-service.com` points to the server hosting the API endpoints like `GET /v1/tasks`.
- **Types**:
  - **Generic TLDs (gTLDs)**: Like `.com`, `.org`, `.info`.
  - **Country-Code TLDs (ccTLDs)**: Like `.uk`, `.ca`, `.br`.
  - **Subdomains**: Used for organizing services (e.g., `www.todo-service.com`, `api.todo-service.com`).
- **Registration**:
  - Purchased through registrars (e.g., GoDaddy, Namecheap).
  - Associated with DNS records (e.g., A, CNAME) to map to IP addresses.
- **Benefits**:
  - User-friendly and memorable.
  - Enables branding (e.g., `todo-service.com` reflects the service identity).
  - Supports multiple services under one domain via subdomains.
- **Challenges**:
  - Requires registration and renewal (usually annual).
  - DNS misconfiguration can cause downtime.
  - Domain squatting or typosquatting can pose security risks.

In backend development, a domain name is critical for making a TODO service API (e.g., `https://api.todo-service.com/v1/tasks`) accessible to users, providing a recognizable and reliable way to reach the server.

### What is SSL?

**SSL** (Secure Sockets Layer) is a cryptographic protocol designed to provide secure communication over a network, such as the internet, by encrypting data transmitted between a client (e.g., a browser or app) and a server. It ensures data confidentiality, integrity, and authentication, and has largely been succeeded by **TLS** (Transport Layer Security), though "SSL" is still commonly used to refer to both.

**Key Points**:

- **Purpose**: Secures data in transit to prevent eavesdropping, tampering, or impersonation, commonly used for HTTPS connections.
- **How It Works**:
  - Establishes an encrypted connection using a handshake process:
    1. The client requests a secure connection.
    2. The server presents an SSL/TLS certificate to prove its identity.
    3. The client verifies the certificate with a trusted Certificate Authority (CA).
    4. A shared encryption key is established (symmetric for speed, using asymmetric encryption for key exchange).
  - Data is encrypted before transmission and decrypted by the recipient.
- **Key Features**:
  - **Encryption**: Protects data (e.g., API payloads, passwords) from interception.
  - **Authentication**: Verifies the server’s identity using certificates.
  - **Data Integrity**: Ensures data isn’t altered during transmission.
- **Example**: In a TODO service:
  - A client sends a `POST /v1/tasks` request to `https://api.todo-service.com`.
  - SSL/TLS encrypts the request (e.g., task data like `{"title": "Buy groceries"}`) and response, ensuring secure communication over port 443 (HTTPS).
- **Certificates**:
  - Issued by trusted CAs (e.g., Let’s Encrypt, DigiCert).
  - Contain the server’s public key and identity (e.g., domain `api.todo-service.com`).
  - Browsers display a padlock icon for valid SSL/TLS connections.
- **Contrast with TLS**:
  - SSL is an older protocol (versions 1.0–3.0, now deprecated due to vulnerabilities).
  - TLS is the modern, more secure successor (versions 1.0–1.3).
  - In practice, “SSL” often refers to TLS in modern contexts (e.g., HTTPS uses TLS).
- **Benefits**:
  - Protects sensitive data (e.g., user credentials, task details).
  - Builds user trust (padlock, HTTPS in browsers).
  - Required for compliance with security standards (e.g., GDPR, PCI-DSS).
- **Challenges**:
  - Requires certificate management (e.g., renewal every 90 days with Let’s Encrypt).
  - Slight performance overhead due to encryption (mitigated by modern hardware).
  - Misconfiguration can lead to vulnerabilities.

In backend development, SSL/TLS is critical for securing a TODO service API (e.g., `https://api.todo-service.com/v1/tasks`), ensuring that client-server communication is encrypted and protected from attacks like man-in-the-middle.

### What is a certificate?

A **certificate**, in the context of backend development and network security, is a digital document used to verify the identity of a server, client, or entity and enable secure communication over a network. It is a core component of protocols like **SSL/TLS** (used in HTTPS) and contains cryptographic keys and metadata to establish trust and encryption.

**Key Points**:

- **Purpose**: Authenticates the identity of a server or client (e.g., ensuring `api.todo-service.com` is legitimate) and provides the public key for secure data exchange.
- **How It Works**:
  - Issued by a trusted **Certificate Authority (CA)** (e.g., Let’s Encrypt, DigiCert).
  - Contains:
    - **Public Key**: Used for encryption or verifying signatures.
    - **Identity Information**: Domain name (e.g., `api.todo-service.com`), organization details.
    - **Issuer**: The CA that issued the certificate.
    - **Validity Period**: Start and end dates (e.g., valid for 90 days).
    - **Signature**: A digital signature from the CA to prove authenticity.
  - During an SSL/TLS handshake, the server presents the certificate to the client, which verifies it against trusted CAs.
- **Example**: In a TODO service:
  - A client accesses `https://api.todo-service.com/v1/tasks`.
  - The server sends its SSL/TLS certificate, proving it is `api.todo-service.com`.
  - The client (e.g., browser) verifies the certificate, ensuring a secure connection for API requests.
- **Types**:
  - **Domain Validated (DV)**: Verifies domain ownership (e.g., Let’s Encrypt certificates).
  - **Organization Validated (OV)**: Verifies the organization’s identity.
  - **Extended Validation (EV)**: Rigorous verification, often for high-trust sites (shows green bar in older browsers).
  - **Self-Signed**: Not trusted by default, used for testing or internal systems.
- **Use Cases**:
  - Securing HTTPS connections for APIs or websites (e.g., `POST /v1/tasks`).
  - Authenticating servers or clients in secure communication (e.g., VPNs, email servers).
  - Signing software or messages to verify integrity.
- **Benefits**:
  - Ensures secure, encrypted communication (prevents eavesdropping).
  - Builds trust by verifying server identity (e.g., padlock icon in browsers).
  - Required for compliance with standards like GDPR or PCI-DSS.
- **Challenges**:
  - **Expiration**: Certificates must be renewed (e.g., every 90 days for Let’s Encrypt).
  - **Misconfiguration**: Incorrect setup can cause errors (e.g., “certificate not trusted” warnings).
  - **Cost**: Some CAs charge for certificates (though free options like Let’s Encrypt exist).
- **Management**: Tools like Certbot automate certificate issuance and renewal for servers hosting APIs.

In backend development, certificates are critical for securing a TODO service API (e.g., `https://api.todo-service.com/v1/tasks`), enabling HTTPS to protect data in transit and ensure users connect to the authentic server.

### What is OAuth?

**OAuth** is an authorization framework that allows a third-party application to access a user's resources on a server without sharing the user's credentials. It enables secure, delegated access by issuing access tokens that grant limited permissions to specific resources for a defined period.

**Key Points**:

- **Purpose**: Facilitates secure access to user data (e.g., profiles, tasks) on a server (e.g., a TODO service API) by third-party apps, without exposing sensitive credentials like passwords.
- **How It Works**:
  - **Authorization Flow**:
    1. The user is redirected to the resource server (e.g., a TODO service) to authenticate and grant permission.
    2. The resource server issues an **authorization code** to the third-party app.
    3. The third-party app exchanges the code for an **access token** (and optionally a **refresh token**) from the authorization server.
    4. The third-party app uses the access token to make API requests on behalf of the user.
  - **Tokens**:
    - **Access Token**: A short-lived credential for accessing resources (e.g., `GET /v1/tasks`).
    - **Refresh Token**: Used to obtain new access tokens when they expire.
- **Example**: In a TODO service:
  - A third-party app (e.g., a calendar app) wants to access a user’s tasks from `https://api.todo-service.com/v1/tasks`.
  - The user logs into the TODO service via OAuth, granting the calendar app permission to read tasks.
  - The calendar app receives an access token and uses it to fetch tasks via the API.
- **Key Components**:
  - **Resource Owner**: The user who owns the data (e.g., the TODO service user).
  - **Client**: The third-party app requesting access (e.g., the calendar app).
  - **Authorization Server**: Issues tokens after user approval (e.g., the TODO service’s auth server).
  - **Resource Server**: Hosts the protected resources (e.g., the TODO service API).
- **Benefits**:
  - **Security**: Avoids sharing user credentials; tokens have limited scope and expiration.
  - **Flexibility**: Supports various grant types (e.g., Authorization Code, Implicit, Client Credentials).
  - **User Control**: Users can revoke access at any time.
- **Challenges**:
  - Complex setup compared to simple API keys.
  - Token management (e.g., handling expiration, revocation) adds overhead.
  - Requires secure token storage to prevent leaks.
- **Use Cases**:
  - “Login with Google/Facebook” for single sign-on (SSO).
  - Allowing third-party apps to access user data (e.g., a calendar app syncing with a TODO service).
  - Machine-to-machine authorization (e.g., Client Credentials flow for server-to-server communication).
- **Contrast with Other Mechanisms**:
  - **OAuth**: Focuses on authorization (what a client can do).
  - **OpenID Connect**: Built on OAuth, focuses on authentication (who the user is).
  - **API Keys**: Simpler but less secure, no user-specific access control.

In backend development, OAuth is critical for securing APIs like a TODO service, enabling third-party apps to safely access user tasks (e.g., `POST /v1/tasks`) while maintaining user privacy and control.

### What is JWT?

**JWT** (JSON Web Token) is a compact, self-contained token format used for securely transmitting information between parties, typically for authentication and authorization in web applications. It is encoded as a JSON object and digitally signed to ensure integrity, commonly used in APIs to verify user identity or permissions.

**Key Points**:

- **Purpose**: Enables secure, stateless authentication and authorization by passing user information (e.g., identity, roles) in a token that can be verified by the server.
- **Structure**: A JWT consists of three parts, separated by dots (`.`):
  - **Header**: Metadata about the token (e.g., algorithm used, like `HS256`).
    ```json title="JWT Header"
    { "alg": "HS256", "typ": "JWT" }
    ```
  - **Payload**: Claims or data (e.g., user ID, roles, expiration).
    ```json title="JWT Payload"
    { "sub": "user123", "role": "admin", "exp": 1696116663 }
    ```
  - **Signature**: A cryptographic signature to verify the token’s authenticity, created using a secret key or public/private key pair.
  - Encoded as Base64 strings: `Header.Payload.Signature` (e.g., `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ1c2VyMTIzIn0.signature`).
- **How It Works**:
  - A client (e.g., a browser or app) authenticates with a server (e.g., via username/password).
  - The server generates a JWT, signs it, and sends it to the client.
  - The client includes the JWT in subsequent requests (e.g., in the `Authorization` header: `Bearer <token>`).
  - The server verifies the token’s signature and checks claims (e.g., expiration) before granting access.
- **Example**: In a TODO service:
  - A user logs into `https://api.todo-service.com/v1/login` with credentials.
  - The server responds with a JWT:
    ```json title="JWT Response"
    {
      "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoiMTIzIiwicm9sZSI6InVzZXIiLCJleHAiOjE2OTYxMTY2NjN9.signature"
    }
    ```
  - The client sends the JWT in the `Authorization` header for a `GET /v1/tasks` request to access tasks.
  - The server verifies the token to ensure the user is authenticated and authorized.
- **Benefits**:
  - **Stateless**: No need to store session data on the server; the token contains all necessary information.
  - **Scalable**: Works well in distributed systems (e.g., microservices).
  - **Secure**: Signed tokens prevent tampering; encryption can be added for confidentiality.
  - **Cross-Domain**: Suitable for single sign-on (SSO) across multiple services.
- **Challenges**:
  - **Token Size**: Larger than simple session IDs, increasing request overhead.
  - **Security Risks**: Stolen tokens can be used until expiration; requires secure storage (e.g., HttpOnly cookies).
  - **Revocation**: Difficult to revoke individual tokens without a server-side blacklist.
  - **Expiration**: Must balance short-lived tokens (security) with user experience (avoid frequent logins).
- **Use Cases**:
  - Authenticating users in RESTful APIs (e.g., securing `POST /v1/tasks` in a TODO service).
  - Authorizing access to specific resources based on claims (e.g., `role: admin`).
  - Enabling SSO across applications or microservices.
- **Contrast with Other Mechanisms**:
  - **Session-Based Authentication**: Stores session data server-side; JWT is stateless.
  - **OAuth**: Focuses on delegated authorization; JWT is a token format often used in OAuth.
  - **API Keys**: Simpler but less secure, no user-specific claims or expiration.

In backend development, JWTs are widely used in APIs like a TODO service to securely authenticate users and authorize access to endpoints (e.g., `https://api.todo-service.com/v1/tasks`), providing a scalable and stateless solution for managing user sessions.

### What is API key?

An **API key** is a unique identifier, typically a string of characters, used to authenticate and control access to an API (Application Programming Interface). It acts as a simple security mechanism to verify that a client (e.g., an application or user) is authorized to make requests to the API.

**Key Points**:

- **Purpose**: Authenticates clients and tracks or restricts their API usage, ensuring only authorized users or applications can access protected endpoints.
- **How It Works**:
  - The API provider issues a unique key to a client (e.g., `xyz12345-abcd-6789-efgh`).
  - The client includes the API key in requests, typically in the HTTP header (e.g., `Authorization: Bearer xyz12345`), query parameter (e.g., `?api_key=xyz12345`), or request body.
  - The server validates the key before processing the request.
- **Example**: In a TODO service:
  - A client wants to access `GET https://api.todo-service.com/v1/tasks`.
  - The request includes the API key: `GET https://api.todo-service.com/v1/tasks?api_key=xyz12345`.
  - The server checks the key against a stored list to grant or deny access.
- **Characteristics**:
  - **Simple Authentication**: Less complex than OAuth or JWT, suitable for basic access control.
  - **Stateless**: No session management; each request is validated independently.
  - **Scoped**: Keys can be restricted to specific endpoints, methods, or usage limits (e.g., 1000 requests/day).
- **Use Cases**:
  - Restricting access to API endpoints (e.g., `POST /v1/tasks` in a TODO service).
  - Tracking usage for billing or monitoring (e.g., rate limiting).
  - Allowing third-party apps to integrate with the API.
- **Benefits**:
  - Easy to implement and use.
  - Enables usage monitoring and rate limiting.
  - Provides basic security for non-sensitive APIs.
- **Challenges**:
  - **Limited Security**: API keys are not tied to specific users and can be easily exposed if not handled securely (e.g., included in URLs or logs).
  - **No Expiration**: Unlike JWTs, API keys often don’t expire unless explicitly revoked.
  - **No Granular Permissions**: Less flexible than OAuth for controlling specific access scopes.
- **Security Best Practices**:
  - Use HTTPS to prevent key interception.
  - Avoid embedding keys in client-side code or URLs.
  - Regenerate or revoke keys periodically or if compromised.
  - Combine with other mechanisms (e.g., OAuth, JWT) for sensitive operations.
- **Contrast with Other Mechanisms**:
  - **API Key**: Simple, static identifier for basic access control.
  - **JWT**: Encodes user-specific claims, supports expiration, and is cryptographically signed.
  - **OAuth**: Delegates authorization, allowing user-specific access with tokens.

In backend development, API keys are commonly used in a TODO service to provide simple, secure access to endpoints like `https://api.todo-service.com/v1/tasks`, particularly for third-party integrations or low-security scenarios, but they should be paired with additional security measures for sensitive operations.

### What is rate limiting?

**Rate limiting** is a technique used to control the number of requests a client (e.g., a user, application, or IP address) can make to an API or server within a specific time period. It helps prevent abuse, protect server resources, and ensure fair usage or availability of services.

**Key Points**:

- **Purpose**: Limits excessive or malicious requests to maintain system performance, prevent overload, and protect against denial-of-service (DoS) attacks.
- **How It Works**:
  - The server sets a threshold for requests (e.g., 100 requests per minute per client).
  - Each request is tracked using identifiers like API keys, IP addresses, or user tokens.
  - If the limit is exceeded, the server rejects further requests, typically returning an HTTP status code like `429 Too Many Requests`.
- **Example**: In a TODO service:
  - The API (`https://api.todo-service.com/v1/tasks`) allows 1000 requests per hour per API key.
  - If a client sends 1001 requests in an hour, the server responds with:
    ```json title="Rate Limit Exceeded"
    {
      "status": "error",
      "message": "Rate limit exceeded. Try again in 60 seconds.",
      "code": 429
    }
    ```
- **Types**:
  - **Fixed Window**: Counts requests in a fixed time window (e.g., 100 requests per minute).
  - **Sliding Window**: Tracks requests over a rolling time period for smoother limits.
  - **Token Bucket**: Allows bursts of requests up to a bucket size, refilled at a steady rate.
  - **Leaky Bucket**: Processes requests at a constant rate, queuing excess requests.
- **Implementation**:
  - Use middleware or libraries (e.g., `express-rate-limit` in Node.js, `RateLimiter` in Spring).
  - Store request counts in memory (e.g., Redis) or a database.
  - Apply limits based on IP, API key, user ID, or endpoint.
- **Benefits**:
  - Prevents server overload and ensures availability for all users.
  - Mitigates abuse or DoS attacks.
  - Supports fair usage in multi-tenant systems (e.g., free vs. paid users).
- **Challenges**:
  - May frustrate legitimate users if limits are too strict.
  - Complex to implement in distributed systems (e.g., coordinating limits across multiple servers).
  - Requires monitoring to adjust limits based on usage patterns.
- **Use Cases**:
  - Restricting API usage in a TODO service (e.g., limiting `POST /v1/tasks` to prevent spam).
  - Enforcing subscription plans (e.g., 500 requests/day for free users).
  - Protecting against brute-force attacks on login endpoints.

In backend development, rate limiting is critical for securing and optimizing APIs like a TODO service, ensuring that endpoints (e.g., `GET /v1/tasks`) remain available and performant under high traffic or malicious activity.

### What is throttling?

**Throttling** is a technique used in computing and networking to limit the rate or frequency at which a system processes requests, executes tasks, or consumes resources. It is closely related to rate limiting but focuses on controlling the speed or volume of operations to prevent overloading a system, ensure fair resource allocation, or maintain performance stability.

**Key Points**:

- **Purpose**: Regulates the flow of requests or tasks to avoid overwhelming a server, database, or network, ensuring consistent performance and preventing abuse.
- **How It Works**:
  - Imposes a cap on the rate of requests or operations (e.g., requests per second, tasks per minute).
  - Excess requests are either delayed (queued), rejected, or throttled to a slower processing rate.
  - Often implemented using algorithms like token bucket or leaky bucket.
- **Example**: In a TODO service:
  - The API (`https://api.todo-service.com/v1/tasks`) is throttled to allow only 10 requests per second per user.
  - If a client sends 15 requests in a second, the server delays or rejects the extra 5 requests, responding with a `429 Too Many Requests` status code.
  - Response example:
    ```json title="JSONRequest Throttled"
    {
      "status": "error",
      "message": "Request throttled. Please try again in 1 second.",
      "code": 429
    }
    ```
- **Types**:
  - **Request Throttling**: Limits API requests (similar to rate limiting).
  - **CPU/Memory Throttling**: Restricts resource usage for a process or container (e.g., in Docker).
  - **Network Throttling**: Controls bandwidth usage (e.g., limiting data transfer rates).
  - **Task Throttling**: Limits the rate of task execution (e.g., background jobs in a queue).
- **Implementation**:
  - Middleware or libraries (e.g., `express-rate-limit` for Node.js, `Spring Boot RateLimiter`).
  - Distributed systems use tools like Redis or Kafka to track and enforce throttling.
  - Cloud providers (e.g., AWS API Gateway) offer built-in throttling features.
- **Benefits**:
  - Prevents server overload and maintains performance under high load.
  - Protects against denial-of-service (DoS) attacks or abusive clients.
  - Ensures fair resource distribution among users or services.
- **Challenges**:
  - Over-throttling can degrade user experience (e.g., slow responses).
  - Requires careful tuning to balance performance and accessibility.
  - Complex to manage in distributed systems with multiple servers.
- **Contrast with Rate Limiting**:
  - **Rate Limiting**: Strictly caps the number of requests in a time period (e.g., 1000 requests/hour), rejecting excess requests.
  - **Throttling**: May allow excess requests but slows their processing or queues them, focusing on controlling the rate of execution.
  - Example: Rate limiting rejects requests beyond a limit; throttling might delay them to maintain a steady processing rate.
- **Use Cases**:
  - Limiting API requests in a TODO service to prevent database overload (e.g., throttling `POST /v1/tasks`).
  - Controlling background job execution (e.g., sending task reminders).
  - Managing bandwidth for large file downloads from an API.

In backend development, throttling is critical for maintaining the stability and performance of APIs like a TODO service, ensuring endpoints (e.g., `GET /v1/tasks`) handle high traffic efficiently while preventing system overload or abuse.

### What is pagination?

**Pagination** is a technique used in web applications and APIs to divide a large dataset into smaller, manageable chunks (pages) that are delivered to the client incrementally. This improves performance, reduces server load, and enhances user experience by avoiding overwhelming amounts of data in a single response.

**Key Points**:

- **Purpose**: Efficiently handles large datasets by retrieving and displaying data in smaller portions, making it easier for clients to process and for servers to manage.
- **How It Works**:
  - The server splits the dataset into pages, each containing a fixed number of records.
  - Clients request specific pages using parameters (e.g., page number, page size) in the API call.
  - The server returns the requested page along with metadata (e.g., total pages, total records).
- **Common Approaches**:
  - **Offset-Based Pagination**: Uses `offset` (starting point) and `limit` (number of records) parameters.
  - **Cursor-Based Pagination**: Uses a cursor (e.g., a unique ID or timestamp) to mark the position in the dataset.
- **Example**: In a TODO service:
  - A `GET /v1/tasks` request retrieves a list of tasks.
  - Offset-based: `GET /v1/tasks?limit=10&offset=20` returns tasks 21–30.
  - Response (JSON):
    ```json title="JSON Response"
    {
      "data": [
        { "id": 21, "title": "Task 21", "status": "pending" },
        { "id": 22, "title": "Task 22", "status": "completed" }
      ],
      "meta": {
        "total": 100,
        "page": 3,
        "limit": 10
      }
    }
    ```
  - Cursor-based: `GET /v1/tasks?cursor=123&limit=10` returns the next 10 tasks after task ID 123.
- **Benefits**:
  - Reduces server load and response time by fetching smaller datasets.
  - Improves client performance (e.g., faster rendering in a UI).
  - Enhances user experience by presenting data in manageable chunks.
- **Challenges**:
  - **Offset-Based**: Inefficient for large datasets (e.g., skipping 10,000 rows is slow).
  - **Cursor-Based**: More complex to implement but better for dynamic datasets.
  - **Consistency**: Data changes (e.g., new tasks added) can affect pagination results.
- **Use Cases**:
  - Displaying task lists in a TODO service API (`GET /v1/tasks`).
  - Loading search results or social media feeds incrementally.
  - Handling large database query results efficiently.

In backend development, pagination is critical for optimizing APIs like a TODO service, ensuring that endpoints (e.g., `GET /v1/tasks`) efficiently deliver large lists of tasks while maintaining performance and usability.

### What is sorting in queries?

**Sorting in queries** refers to the process of arranging the results of a database or API query in a specific order based on one or more columns or fields. It is used to organize data in a meaningful way, such as ascending (ASC) or descending (DESC) order, to meet application or user requirements.

**Key Points**:

- **Purpose**: Organizes query results to make data easier to understand, display, or process, improving usability and relevance.
- **How It Works**:
  - A query specifies the column(s) to sort by and the order (ascending or descending).
  - The database or API processes the query and returns results sorted according to the specified criteria.
- **Example**: In a TODO service:
  - Query to retrieve tasks sorted by due date in ascending order:

    ```sql title="SQL Sorting"
    SELECT * FROM tasks ORDER BY due_date ASC;
    ```

    - Returns tasks with earlier due dates first.

  - API request: `GET https://api.todo-service.com/v1/tasks?sort=due_date&order=asc`
    - Response (JSON):
      ```json title="JSON Response"
      [
        { "id": 1, "title": "Buy groceries", "due_date": "2025-10-01" },
        { "id": 2, "title": "Finish report", "due_date": "2025-10-02" }
      ]
      ```
  - Sorting by multiple fields:

    ```sql title="SQL Sorting"
    SELECT * FROM tasks ORDER BY status ASC, due_date DESC;
    ```

    - Sorts tasks by `status` (e.g., "completed" before "pending"), then by `due_date` (latest first within each status).

- **Common Implementations**:
  - **SQL**: Uses the `ORDER BY` clause (e.g., `ORDER BY title ASC`).
  - **API**: Uses query parameters (e.g., `?sort=column&order=asc`).
  - **NoSQL**: Databases like MongoDB use methods like `.sort({ due_date: 1 })` for ascending or `.sort({ due_date: -1 })` for descending.
- **Use Cases**:
  - Displaying tasks in a TODO app by priority, due date, or creation time.
  - Sorting search results by relevance or price in e-commerce.
  - Ordering user lists alphabetically by name.
- **Benefits**:
  - Improves user experience by presenting data in a logical order.
  - Enables flexible data presentation (e.g., sort by newest or oldest tasks).
- **Challenges**:
  - **Performance**: Sorting large datasets can be slow without proper indexing.
  - **Complexity**: Sorting on multiple fields or dynamic fields increases query complexity.
  - **Consistency**: Sorting dynamic data (e.g., frequently updated tasks) may yield inconsistent results without pagination or cursors.
- **Optimization**:
  - Use database indexes on frequently sorted columns (e.g., `due_date`) to speed up queries.
  - Combine with pagination to limit the number of sorted records.

In backend development, sorting in queries is essential for a TODO service API (e.g., `GET /v1/tasks`) to deliver task data in a user-friendly order, enhancing usability and meeting specific application requirements.

### What is filtering in APIs?

**Filtering in APIs** is the process of narrowing down the data returned by an API endpoint based on specific criteria or conditions provided in the request. It allows clients to retrieve only the subset of data that matches the specified parameters, improving efficiency and relevance of the response.

**Key Points**:

- **Purpose**: Enables clients to request specific data from an API, reducing the amount of data transferred and processed, and tailoring results to their needs.
- **How It Works**:
  - Clients include query parameters in the API request to define filtering conditions (e.g., field values, ranges, or patterns).
  - The server processes these parameters, queries the database or data source, and returns only the matching records.
- **Example**: In a TODO service:
  - Request: `GET https://api.todo-service.com/v1/tasks?status=pending&due_date=2025-10-01`
    - Filters tasks to return only those with `status="pending"` and `due_date="2025-10-01"`.
    - Response (JSON):
      ```json title="JSON Response"
      [
        { "id": 1, "title": "Buy groceries", "status": "pending", "due_date": "2025-10-01" },
        { "id": 3, "title": "Call client", "status": "pending", "due_date": "2025-10-01" }
      ]
      ```
  - Another example: `GET /v1/tasks?priority=high` returns only high-priority tasks.
- **Common Implementations**:
  - **Query Parameters**: Use key-value pairs in the URL (e.g., `?status=completed`).
  - **SQL Backend**: Translated to `WHERE` clauses (e.g., `SELECT * FROM tasks WHERE status = 'completed'`).
  - **NoSQL Backend**: Uses query methods (e.g., MongoDB’s `find({ status: 'completed' })`).
  - **Complex Filters**: Support operators like `gt` (greater than), `lt` (less than), or `contains` (e.g., `?due_date_gt=2025-10-01`).
- **Use Cases**:
  - Retrieving tasks by status, date, or user in a TODO service API.
  - Filtering products by category or price in an e-commerce API.
  - Searching users by name or role in a user management system.
- **Benefits**:
  - Reduces data transfer by returning only relevant results.
  - Improves performance by minimizing server processing and network load.
  - Enhances user experience by providing precise data.
- **Challenges**:
  - **Complexity**: Supporting complex filters (e.g., multiple conditions) increases server-side logic.
  - **Performance**: Poorly designed filters or missing database indexes can slow queries.
  - **Security**: Must validate and sanitize filter inputs to prevent injection attacks (e.g., SQL injection).
- **Best Practices**:
  - Combine with pagination to handle large filtered datasets (e.g., `?status=pending&limit=10`).
  - Use indexes on frequently filtered columns (e.g., `status`, `due_date`).
  - Validate filter parameters to ensure security and correctness.

In backend development, filtering is critical for optimizing APIs like a TODO service, enabling clients to efficiently retrieve specific data (e.g., `GET /v1/tasks?status=pending`) while reducing server load and improving usability.

### What is aggregation in databases?

**Aggregation** in databases is the process of combining and summarizing data from multiple records to produce a single result, often to derive meaningful insights or metrics. It involves applying functions like counting, summing, averaging, or grouping to data, typically in relational or NoSQL databases.

**Key Points**:

- **Purpose**: Simplifies large datasets by computing summary statistics or grouping data based on specific criteria, making it easier to analyze or report.
- **How It Works**:
  - Aggregation functions process data across rows or documents to produce a single value or grouped results.
  - Commonly used with queries to group, filter, or calculate data.
- **Common Aggregation Functions**:
  - **COUNT**: Counts the number of records (e.g., total tasks).
  - **SUM**: Adds values in a column (e.g., total hours spent on tasks).
  - **AVG**: Calculates the average of values (e.g., average task duration).
  - **MIN/MAX**: Finds the smallest or largest value (e.g., earliest due date).
  - **GROUP BY**: Groups records by a column and applies aggregation functions to each group.
- **Example**: In a TODO service:
  - SQL Query to count tasks by status:

    ```sql title="SQL Aggregation"
    SELECT status, COUNT(*) as task_count
    FROM tasks
    GROUP BY status;
    ```

    - Result:
      ```json title="JSON Response"
      [
        { "status": "pending", "task_count": 50 },
        { "status": "completed", "task_count": 30 }
      ]
      ```

  - MongoDB Query to calculate average task duration:

    ```javascript title="MongoDB Aggregation"
    db.tasks.aggregate([{ $group: { _id: null, avg_duration: { $avg: '$duration' } } }])
    ```

    - Result: `{"_id": null, "avg_duration": 4.5}` (hours).

- **Use Cases**:
  - Generating reports (e.g., number of tasks per user in a TODO service).
  - Calculating metrics (e.g., average completion time for tasks).
  - Summarizing data for dashboards (e.g., tasks completed per day).
- **Benefits**:
  - Simplifies data analysis by reducing large datasets to meaningful summaries.
  - Supports business intelligence and decision-making.
  - Efficiently handles large volumes of data with proper indexing.
- **Challenges**:
  - **Performance**: Aggregations on large datasets can be slow without indexes or optimization.
  - **Complexity**: Complex aggregations (e.g., multiple groups or joins) require careful query design.
  - **Accuracy**: Must account for null or missing data to avoid skewed results.
- **Implementation**:
  - **Relational Databases**: Use SQL `GROUP BY` with functions like `COUNT`, `SUM` (e.g., MySQL, PostgreSQL).
  - **NoSQL Databases**: Use aggregation pipelines (e.g., MongoDB’s `$group`, `$sum`).
  - **APIs**: Expose aggregated data via endpoints (e.g., `GET /v1/tasks/stats?group_by=status`).

In backend development, aggregation is critical for a TODO service to provide insights, such as summarizing task statuses or user activity, enabling efficient reporting and analytics while optimizing API performance.

### What is a join in SQL?

A **JOIN** in SQL is a clause used to combine rows from two or more tables in a relational database based on a related column, typically a primary key or foreign key, to create a unified result set. It enables querying data from multiple tables that are related to each other.

**Key Points**:

- **Purpose**: Retrieves data from multiple tables by linking them on a common column, allowing complex queries that combine related information.
- **How It Works**:
  - The `JOIN` clause specifies the tables to combine and the condition (using `ON`) that defines how rows are matched.
  - The database matches rows based on the condition and returns the combined results.
- **Common Types of JOINs**:
  - **INNER JOIN**: Returns only the rows where there is a match in both tables.

    ```sql title="SQL Join"
    SELECT tasks.id, tasks.title, users.name
    FROM tasks
    INNER JOIN users ON tasks.user_id = users.id;
    ```

    - Returns tasks with their associated user names, excluding tasks or users without matches.

  - **LEFT (OUTER) JOIN**: Returns all rows from the left table and matching rows from the right table; non-matching rows from the right table return NULL.

    ```sql title="SQL Join"
    SELECT tasks.id, tasks.title, users.name
    FROM tasks
    LEFT JOIN users ON tasks.user_id = users.id;
    ```

    - Returns all tasks, even if no user is associated (e.g., `users.name` is NULL).

  - **RIGHT (OUTER) JOIN**: Returns all rows from the right table and matching rows from the left table; non-matching rows from the left table return NULL.
  - **FULL (OUTER) JOIN**: Returns all rows from both tables, with NULLs for non-matching rows.

- **Example**: In a TODO service:
  - Tables:
    - `tasks`: Columns `id`, `title`, `user_id` (foreign key).
    - `users`: Columns `id`, `name`.
  - Query to get tasks with their user names:

    ```sql title="SQL Join"
    SELECT tasks.title, users.name
    FROM tasks
    INNER JOIN users ON tasks.user_id = users.id
    WHERE tasks.status = 'pending';
    ```

    - Result:
      ```json title="JSON Response"
      [
        { "title": "Buy groceries", "name": "John" },
        { "title": "Finish report", "name": "Alice" }
      ]
      ```

- **Use Cases**:
  - Retrieving related data (e.g., tasks and their owners in a TODO service).
  - Combining user profiles with their activity logs.
  - Aggregating data across tables (e.g., counting tasks per user).
- **Benefits**:
  - Enables complex queries by linking related data.
  - Supports normalized database designs by combining data from separate tables.
- **Challenges**:
  - **Performance**: JOINs on large tables can be slow without proper indexing.
  - **Complexity**: Multiple or nested JOINs can make queries harder to write and maintain.
  - **NULL Handling**: Requires careful handling of NULLs in OUTER JOINs.
- **Optimization**:
  - Use indexes on columns used in the `ON` clause (e.g., `user_id`, `id`).
  - Limit the number of JOINs to reduce query complexity.
  - Filter rows early with `WHERE` to minimize data processed.

In backend development, JOINs are essential for a TODO service API (e.g., `GET /v1/tasks`) to fetch related data, such as tasks and their associated user details, enabling efficient and meaningful data retrieval from normalized databases.

### What is a view in databases?

A **view** in a database is a virtual table created by a query that combines data from one or more tables, presenting it as if it were a single table. It does not store data physically but dynamically generates results when queried, based on the underlying tables.

**Key Points**:

- **Purpose**: Simplifies complex queries, enhances security, and provides a customized or simplified view of data for users or applications.
- **How It Works**:
  - Defined using a `CREATE VIEW` statement with an SQL query that specifies the data to include.
  - Acts as a stored query that can be queried like a regular table.
  - Updates to the underlying tables are reflected in the view, but views are read-only in most cases unless explicitly updatable.
- **Example**: In a TODO service:
  - Tables:
    - `tasks`: Columns `id`, `title`, `user_id`, `status`, `due_date`.
    - `users`: Columns `id`, `name`.
  - Create a view to show pending tasks with user names:
    ```sql title="SQL View"
    CREATE VIEW pending_tasks AS
    SELECT tasks.id, tasks.title, users.name, tasks.due_date
    FROM tasks
    INNER JOIN users ON tasks.user_id = users.id
    WHERE tasks.status = 'pending';
    ```
  - Query the view:

    ```sql title="SQL Query"
    SELECT * FROM pending_tasks;
    ```

    - Result:
      ```json title="JSON Response"
      [
        { "id": 1, "title": "Buy groceries", "name": "John", "due_date": "2025-10-01" },
        { "id": 3, "title": "Call client", "name": "Alice", "due_date": "2025-10-02" }
      ]
      ```

- **Types**:
  - **Simple View**: Based on a single table, often updatable.
  - **Complex View**: Involves multiple tables, joins, or aggregations, typically read-only.
  - **Materialized View**: Stores data physically for performance, updated periodically (supported by some databases like PostgreSQL).
- **Use Cases**:
  - Simplifying complex queries for a TODO service API (e.g., `GET /v1/pending-tasks` using a view).
  - Restricting access to specific columns or rows for security (e.g., hiding sensitive user data).
  - Providing aggregated data (e.g., task counts per user).
- **Benefits**:
  - **Simplicity**: Abstracts complex queries into a single, reusable interface.
  - **Security**: Limits access to specific data (e.g., only show `title` and `name`, not `user_id`).
  - **Maintainability**: Centralizes query logic, making updates easier.
- **Challenges**:
  - **Performance**: Complex views with joins or aggregations can be slow without optimization.
  - **Read-Only**: Most views are not updatable unless designed specifically (e.g., simple views with triggers).
  - **Dependencies**: Changes to underlying tables can break views.
- **Optimization**:
  - Use indexes on underlying tables for faster query execution.
  - Consider materialized views for frequently accessed, complex data.

In backend development, views are valuable for a TODO service API to simplify data access (e.g., fetching pending tasks with user details), enhance security, and streamline query logic for endpoints like `GET /v1/tasks`.

### What is a stored procedure?

A **stored procedure** is a precompiled set of SQL statements stored in a database under a specific name, which can be executed repeatedly as a single unit. It is used to encapsulate complex database operations, improve performance, and enhance security by centralizing logic on the database server.

**Key Points**:

- **Purpose**: Simplifies complex database tasks, ensures consistent execution, and reduces application-side logic by running predefined SQL code on the server.
- **How It Works**:
  - Defined using a `CREATE PROCEDURE` statement with SQL and optional parameters.
  - Stored in the database and invoked by applications or other database processes using a `CALL` or `EXEC` command.
  - Can include logic like loops, conditionals, or error handling, depending on the database system.
- **Example**: In a TODO service:
  - A stored procedure to create a task and log the action in an audit table:

    ```sql title="SQL Procedure"
    CREATE PROCEDURE AddTask(
        IN p_user_id INT,
        IN p_title VARCHAR(100),
        IN p_status VARCHAR(20)
    )
    BEGIN
        INSERT INTO tasks (user_id, title, status)
        VALUES (p_user_id, p_title, p_status);

        INSERT INTO audit_log (user_id, action, timestamp)
        VALUES (p_user_id, 'Task Created', NOW());
    END;
    ```

  - Call the procedure:
    ```sql title="SQL Procedure Call"
    CALL AddTask(123, 'Buy groceries', 'pending');
    ```
  - Result: A new task is added to the `tasks` table, and an entry is logged in the `audit_log` table.

- **Use Cases**:
  - Encapsulating complex operations (e.g., creating a task and updating related tables in a TODO service).
  - Performing batch updates or data migrations.
  - Enforcing business rules (e.g., validating task status before insertion).
  - Reducing network traffic by executing logic server-side.
- **Benefits**:
  - **Performance**: Precompiled procedures execute faster than ad-hoc queries.
  - **Security**: Restricts direct table access; users can execute procedures without table permissions.
  - **Maintainability**: Centralizes logic, making updates easier without changing application code.
  - **Reusability**: Can be called multiple times by different applications or users.
- **Challenges**:
  - **Complexity**: Writing and debugging complex procedures can be difficult.
  - **Portability**: Syntax varies across databases (e.g., MySQL, PostgreSQL, SQL Server).
  - **Version Control**: Managing procedures in source control can be challenging compared to application code.
- **Support**: Available in relational databases like MySQL, PostgreSQL, SQL Server, and Oracle, but not in most NoSQL databases.

In backend development, stored procedures are useful for a TODO service to handle complex operations (e.g., `POST /v1/tasks` triggering multiple table updates) efficiently and securely, reducing application complexity and improving database performance.

### What is a trigger?

A **trigger** in a database is a stored procedure or set of SQL statements that automatically executes in response to specific events on a table, such as `INSERT`, `UPDATE`, or `DELETE` operations. It is used to enforce business rules, maintain data integrity, or automate tasks within the database.

**Key Points**:

- **Purpose**: Automatically performs actions (e.g., updating related tables, logging changes) when a specified database event occurs, reducing application-side logic.
- **How It Works**:
  - Defined using a `CREATE TRIGGER` statement, specifying the event, timing (before or after), and action.
  - Executes automatically when the triggering event occurs on the specified table.
  - Can access old and new data values for the affected rows.
- **Types**:
  - **BEFORE Trigger**: Executes before the event (e.g., to validate or modify data before insertion).
  - **AFTER Trigger**: Executes after the event (e.g., to log changes or update related tables).
  - **INSTEAD OF Trigger**: Replaces the triggering action (used with views).
- **Example**: In a TODO service:
  - A trigger to log task updates in an audit table:
    ```sql title="SQL Trigger"
    CREATE TRIGGER log_task_update
    AFTER UPDATE ON tasks
    FOR EACH ROW
    BEGIN
        INSERT INTO audit_log (user_id, action, timestamp, task_id)
        VALUES (NEW.user_id, 'Task Updated', NOW(), NEW.id);
    END;
    ```
  - When a task is updated (e.g., `UPDATE tasks SET status = 'completed' WHERE id = 1`), the trigger automatically logs the change in the `audit_log` table.
- **Use Cases**:
  - Enforcing data integrity (e.g., ensuring a task’s `due_date` is not in the past).
  - Logging changes (e.g., tracking task status updates in a TODO service).
  - Updating related tables (e.g., incrementing a user’s task count when a new task is added).
  - Automating cascading actions (e.g., deleting related comments when a task is deleted).
- **Benefits**:
  - **Automation**: Executes logic automatically, reducing application code.
  - **Consistency**: Ensures rules are enforced at the database level.
  - **Security**: Runs with database privileges, bypassing application vulnerabilities.
- **Challenges**:
  - **Complexity**: Hard to debug or trace, especially with cascading triggers.
  - **Performance**: Can slow down operations if triggers are complex or numerous.
  - **Portability**: Syntax varies across databases (e.g., MySQL, PostgreSQL, SQL Server).
- **Support**: Available in relational databases like MySQL, PostgreSQL, SQL Server, and Oracle, but not in most NoSQL databases.

In backend development, triggers are valuable for a TODO service to automate tasks like logging or updating related data when actions occur (e.g., `POST /v1/tasks` or `PUT /v1/tasks/123`), ensuring data consistency and reducing application logic complexity.

### What is NoSQL?

**NoSQL** (Not Only SQL) refers to a category of database management systems designed to handle large-scale, unstructured, semi-structured, or structured data, offering flexibility, scalability, and performance advantages over traditional relational (SQL) databases for certain use cases. Unlike SQL databases, NoSQL databases are not strictly tied to tabular structures or fixed schemas.

**Key Points**:

- **Purpose**: Provides a flexible, scalable way to store and retrieve data, especially for big data, real-time, or dynamic applications.
- **How It Works**:
  - Stores data in various formats (e.g., key-value, document, column-family, graph) rather than fixed tables with rows and columns.
  - Typically schema-less or schema-flexible, allowing easier adaptation to changing data structures.
  - Optimized for horizontal scaling across distributed systems (e.g., adding more servers).
- **Types of NoSQL Databases**:
  - **Key-Value Stores**: Simple key-value pairs (e.g., Redis, DynamoDB).
    - Example: `task_id:123 -> {"title": "Buy groceries"}`
  - **Document Stores**: Store semi-structured JSON or BSON documents (e.g., MongoDB, CouchDB).
    - Example: `{id: 123, title: "Buy groceries", status: "pending"}`
  - **Column-Family Stores**: Organize data in columns for analytics (e.g., Cassandra, HBase).
  - **Graph Databases**: Store relationships as nodes and edges (e.g., Neo4j).
- **Example**: In a TODO service:
  - Using MongoDB (document store):
    ```javascript title="MongoDB Document Store"
    db.tasks.insertOne({
      id: 123,
      title: 'Buy groceries',
      status: 'pending',
      tags: ['urgent', 'personal'],
      due_date: '2025-10-01',
    })
    ```
  - Query: `db.tasks.find({ status: "pending" })` retrieves all pending tasks.
  - API: `GET https://api.todo-service.com/v1/tasks?status=pending` returns matching documents.
- **Benefits**:
  - **Scalability**: Easily scales horizontally across multiple servers.
  - **Flexibility**: Handles diverse data types and schema changes without migrations.
  - **Performance**: Optimized for specific workloads (e.g., high read/write throughput).
  - **Big Data**: Suits large-scale, unstructured data (e.g., social media, IoT).
- **Challenges**:
  - **Consistency**: Often prioritizes availability and partition tolerance over immediate consistency (CAP theorem).
  - **Complexity**: Requires understanding different data models and query languages.
  - **Less Mature**: Fewer standardization and tooling compared to SQL databases.
- **Contrast with SQL**:
  - **SQL**: Fixed schemas, tabular data, ACID transactions, vertical scaling, suited for structured data.
  - **NoSQL**: Flexible schemas, diverse data models, eventual consistency (often), horizontal scaling, suited for unstructured or semi-structured data.
- **Use Cases**:
  - Storing tasks in a TODO service with flexible fields (e.g., variable task attributes).
  - Real-time analytics, caching, or content management.
  - Handling high-traffic or large-scale data in microservices.

In backend development, NoSQL databases like MongoDB or Redis are used in a TODO service to store and query tasks flexibly, supporting scalable APIs (e.g., `POST /v1/tasks`) for dynamic or high-traffic applications, though they may require careful design to ensure data consistency.

### What is a key-value store?

A **key-value store** is a type of NoSQL database that stores data as a collection of key-value pairs, where each key is a unique identifier associated with a specific value. It is designed for simplicity, high performance, and scalability, particularly for fast data retrieval and storage.

**Key Points**:

- **Purpose**: Provides a straightforward way to store, retrieve, and manage data using unique keys, ideal for high-speed, simple lookups.
- **How It Works**:
  - Data is stored as pairs: a key (e.g., a string or ID) maps to a value (e.g., a string, number, JSON object, or binary data).
  - Operations include `get` (retrieve value by key), `set` (store a key-value pair), and `delete` (remove a key-value pair).
  - Typically operates in memory or with persistent storage for durability.
- **Example**: In a TODO service:
  - Store a task:
    ```plaintext title="Key-Value Store"
    Key: task:123
    Value: {"id": 123, "title": "Buy groceries", "status": "pending"}
    ```
  - Retrieve: `GET task:123` returns the task’s JSON data.
  - API: A `GET https://api.todo-service.com/v1/tasks/123` request might fetch the value from a key-value store like Redis.
- **Characteristics**:
  - **Simple Data Model**: No complex schemas or relationships like relational databases.
  - **High Performance**: Fast read/write operations, especially for in-memory stores like Redis.
  - **Scalability**: Easily scales horizontally across distributed systems (e.g., DynamoDB).
  - **Eventual Consistency**: Many key-value stores prioritize availability over immediate consistency (CAP theorem).
- **Common Implementations**:
  - **Redis**: In-memory store for caching, sessions, or real-time data.
  - **DynamoDB**: Managed, distributed key-value store by AWS.
  - **Memcached**: In-memory caching for simple key-value pairs.
  - **Riak, etcd**: Distributed key-value stores for specific use cases.
- **Use Cases**:
  - Caching API responses in a TODO service (e.g., caching `GET /v1/tasks` results in Redis).
  - Storing user sessions (e.g., `session:abc123 -> {user_id: 456}`).
  - Real-time analytics or configuration storage.
- **Benefits**:
  - Extremely fast for simple lookups and writes.
  - Flexible values (can store strings, JSON, or binary data).
  - Scales well for high-traffic applications.
- **Challenges**:
  - Limited query capabilities (no complex joins or aggregations like SQL).
  - No built-in relationships (not ideal for complex data models).
  - Consistency trade-offs in distributed setups.
- **Contrast with Other Databases**:
  - **Key-Value Store**: Simple, key-based access, no schema (e.g., Redis).
  - **Relational (SQL)**: Structured tables, supports joins and complex queries.
  - **Document Store**: Stores structured documents (e.g., MongoDB), supports richer queries.

In backend development, a key-value store like Redis is ideal for a TODO service to cache task data, manage user sessions, or store temporary states, enhancing performance for API endpoints like `GET /v1/tasks` in high-traffic scenarios.

### What is a document database?

A **document database** is a type of NoSQL database that stores data as semi-structured documents, typically in formats like JSON or BSON (Binary JSON), rather than in tables like relational databases. Each document is a self-contained unit with its own data structure, allowing for flexible and schema-less storage.

**Key Points**:

- **Purpose**: Stores and retrieves data in a flexible, hierarchical format, ideal for applications with dynamic or complex data structures.
- **How It Works**:
  - Data is stored as collections of documents, where each document is a key-value structure (e.g., JSON).
  - Documents can have different fields and structures within the same collection, unlike the fixed schemas of SQL databases.
  - Supports queries based on document fields, including nested fields, and often provides indexing for faster retrieval.
- **Example**: In a TODO service using a document database like MongoDB:
  - A document in the `tasks` collection:
    ```json title="JSON Document"
    {
      "_id": 123,
      "title": "Buy groceries",
      "status": "pending",
      "due_date": "2025-10-01",
      "tags": ["urgent", "personal"],
      "user": {
        "user_id": 456,
        "name": "John"
      }
    }
    ```
  - Query to find pending tasks:
    ```javascript title="JavaScript Query"
    db.tasks.find({ status: 'pending' })
    ```
  - API: `GET https://api.todo-service.com/v1/tasks?status=pending` returns matching documents.
- **Characteristics**:
  - **Schema-less**: Documents can vary in structure (e.g., some tasks may have `tags`, others may not).
  - **Hierarchical**: Supports nested data (e.g., `user` object within a task).
  - **Scalability**: Designed for horizontal scaling across distributed systems.
  - **Query Flexibility**: Supports queries on any field, aggregations, and indexing.
- **Common Implementations**:
  - **MongoDB**: Popular document database with rich query support and BSON storage.
  - **CouchDB**: Focuses on replication and offline support.
  - **Firestore**: Managed document database by Google Cloud.
- **Use Cases**:
  - Storing tasks with variable fields in a TODO service (e.g., some tasks have due dates, others have priorities).
  - Managing user profiles, content management systems, or e-commerce product catalogs.
  - Real-time applications with dynamic data (e.g., event logging).
- **Benefits**:
  - **Flexibility**: Adapts to changing data structures without schema migrations.
  - **Scalability**: Easily scales horizontally for high-traffic applications.
  - **Intuitive**: JSON-like documents align with modern application data formats.
- **Challenges**:
  - **Consistency**: Often prioritizes availability over immediate consistency (CAP theorem).
  - **Complex Queries**: Joins are less straightforward than in SQL databases.
  - **Storage Overhead**: Nested documents can increase storage needs compared to normalized tables.
- **Contrast with Other Databases**:
  - **Document Database**: Stores flexible JSON/BSON documents (e.g., MongoDB).
  - **Relational (SQL)**: Uses fixed-schema tables with rows/columns and supports joins.
  - **Key-Value Store**: Simple key-value pairs, limited query capabilities (e.g., Redis).

In backend development, document databases like MongoDB are ideal for a TODO service to store tasks with varying attributes, supporting flexible and scalable APIs (e.g., `POST /v1/tasks`) for dynamic applications, though they require careful design for consistency and complex queries.

### What is a graph database?

A **graph database** is a type of NoSQL database that uses graph structures to store, manage, and query data, focusing on relationships between entities. It represents data as nodes (entities), edges (relationships), and properties (attributes), making it ideal for applications where relationships are as important as the data itself.

**Key Points**:

- **Purpose**: Efficiently stores and queries complex relationships between data, enabling fast traversal and analysis of interconnected data.
- **How It Works**:
  - **Nodes**: Represent entities (e.g., users, tasks).
  - **Edges**: Represent relationships between nodes (e.g., "created by," "depends on").
  - **Properties**: Attributes of nodes or edges (e.g., task title, user name).
  - Queries traverse the graph to find patterns, relationships, or paths (e.g., shortest path between nodes).
- **Example**: In a TODO service:
  - Nodes: `User` (e.g., "John"), `Task` (e.g., "Buy groceries").
  - Edges: `CREATED` (John created the task), `DEPENDS_ON` (Task A depends on Task B).
  - Sample data in a graph database (e.g., Neo4j):
    ```cypher title="Cypher Query Language"
    CREATE (u:User {id: 123, name: "John"})
    CREATE (t:Task {id: 456, title: "Buy groceries", status: "pending"})
    CREATE (u)-[:CREATED]->(t);
    ```
  - Query to find tasks created by a user:

    ```cypher title="Cypher Query Language"
    MATCH (u:User {id: 123})-[:CREATED]->(t:Task)
    RETURN t.title, t.status;
    ```

    - Result: `{"title": "Buy groceries", "status": "pending"}`

  - API: `GET https://api.todo-service.com/v1/users/123/tasks` could leverage this query.

- **Common Implementations**:
  - **Neo4j**: Popular graph database with Cypher query language.
  - **ArangoDB**: Multi-model database supporting graphs.
  - **Amazon Neptune**: Managed graph database in AWS.
- **Use Cases**:
  - Managing task dependencies in a TODO service (e.g., Task A must be completed before Task B).
  - Social networks (e.g., friend connections).
  - Recommendation systems (e.g., suggesting related tasks).
  - Fraud detection or network analysis.
- **Benefits**:
  - **Relationship-Focused**: Optimized for querying complex relationships (e.g., multi-level task dependencies).
  - **Performance**: Fast traversals for interconnected data, even with large datasets.
  - **Flexibility**: Easily adapts to evolving relationships without schema changes.
- **Challenges**:
  - **Complexity**: Graph query languages (e.g., Cypher) have a learning curve.
  - **Scalability**: Less straightforward to scale horizontally compared to other NoSQL databases.
  - **Not Universal**: Best for relationship-heavy data, less efficient for simple key-value or tabular data.
- **Contrast with Other Databases**:
  - **Graph Database**: Excels at relationship queries (e.g., Neo4j).
  - **Relational (SQL)**: Uses tables and joins, less efficient for complex relationships.
  - **Document Store**: Stores JSON-like documents, not optimized for relationships (e.g., MongoDB).
  - **Key-Value Store**: Simple key-value pairs, no relationship support (e.g., Redis).

In backend development, a graph database is ideal for a TODO service when managing complex relationships, such as task dependencies or user-task interactions, enabling efficient queries for APIs (e.g., `GET /v1/tasks/dependencies`) but may be overkill for simple CRUD operations.

### What is a relational database?

A **relational database** is a type of database that organizes data into structured tables, where each table contains rows and columns, and relationships between tables are established using keys (e.g., primary and foreign keys). It uses a fixed schema to define the structure of data and relies on SQL (Structured Query Language) for querying and managing data.

**Key Points**:

- **Purpose**: Stores and manages structured data with clear relationships, enabling efficient querying, data integrity, and consistency for applications.
- **How It Works**:
  - Data is stored in **tables**, each representing an entity (e.g., users, tasks).
  - Each table has **columns** (attributes, e.g., `id`, `title`) and **rows** (individual records).
  - **Primary Key**: A unique identifier for each row in a table (e.g., `task_id`).
  - **Foreign Key**: A column that links to the primary key of another table, establishing relationships.
  - Queries use SQL to retrieve, insert, update, or delete data, often combining tables with `JOIN` operations.
- **Example**: In a TODO service:
  - Tables:
    - `users`: Columns `id` (primary key), `name`, `email`.
    - `tasks`: Columns `task_id` (primary key), `title`, `status`, `user_id` (foreign key referencing `users.id`).
  - Query to get tasks with user names:

    ```sql title="SQL Query"
    SELECT tasks.title, users.name
    FROM tasks
    JOIN users ON tasks.user_id = users.id
    WHERE tasks.status = 'pending';
    ```

    - Result:
      ```json title="JSON Response"
      [
        { "title": "Buy groceries", "name": "John" },
        { "title": "Finish report", "name": "Alice" }
      ]
      ```

  - API: `GET https://api.todo-service.com/v1/tasks?status=pending` could use this query.

- **Characteristics**:
  - **Fixed Schema**: Tables have predefined columns and data types.
  - **ACID Compliance**: Ensures Atomicity, Consistency, Isolation, Durability for reliable transactions.
  - **Relationships**: Supports complex queries using joins to link related data.
  - **Standardized**: Uses SQL for consistent querying across databases (e.g., MySQL, PostgreSQL).
- **Common Implementations**:
  - **MySQL**: Open-source, widely used for web applications.
  - **PostgreSQL**: Advanced features, strong standards compliance.
  - **SQL Server**: Microsoft’s enterprise solution.
  - **Oracle**: Robust for large-scale enterprise systems.
- **Use Cases**:
  - Managing structured data in a TODO service (e.g., tasks, users, and their relationships).
  - Financial systems, inventory management, or CRM applications requiring strong consistency.
  - Applications needing complex queries (e.g., reporting or analytics).
- **Benefits**:
  - **Data Integrity**: Enforces relationships and constraints (e.g., foreign keys).
  - **Powerful Queries**: Supports joins, aggregations, and filtering.
  - **Mature Ecosystem**: Extensive tools and community support.
- **Challenges**:
  - **Scalability**: Vertical scaling is common; horizontal scaling is complex compared to NoSQL.
  - **Schema Rigidity**: Changes to schema (e.g., adding columns) require migrations.
  - **Performance**: Complex joins on large datasets can be slow without optimization.
- **Contrast with NoSQL**:
  - **Relational (SQL)**: Fixed schemas, tables, strong consistency, suited for structured data.
  - **NoSQL**: Flexible schemas, diverse data models (e.g., document, key-value), suited for unstructured or scalable data.

In backend development, relational databases are ideal for a TODO service to manage structured data (e.g., tasks and users) with strong consistency, supporting APIs (e.g., `POST /v1/tasks`) and complex queries, though they may require careful optimization for high-scale scenarios.

### What is ORM?

**ORM** (Object-Relational Mapping) is a programming technique that allows developers to interact with a relational database using object-oriented programming constructs instead of writing raw SQL queries. It maps database tables to classes, rows to objects, and columns to object attributes, simplifying database operations in application code.

**Key Points**:

- **Purpose**: Abstracts database interactions, enabling developers to work with database records as objects in their programming language, reducing the need for manual SQL and improving productivity.
- **How It Works**:
  - An ORM library or framework defines a mapping between database tables and application classes.
  - Developers use object-oriented methods (e.g., `save()`, `find()`) to perform CRUD operations (Create, Read, Update, Delete).
  - The ORM translates these operations into SQL queries executed against the database.
- **Example**: In a TODO service using an ORM like Sequelize (Node.js):
  - Define a `Task` model mapping to the `tasks` table:

    ```javascript title="JavaScript Query"
    const { Sequelize, DataTypes } = require('sequelize')
    const sequelize = new Sequelize('sqlite::memory:')

    const Task = sequelize.define('Task', {
      id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },
      title: { type: DataTypes.STRING },
      status: { type: DataTypes.STRING },
    })
    ```

  - Create a task:
    ```javascript title="JavaScript Query"
    await Task.create({ title: 'Buy groceries', status: 'pending' })
    ```
  - Query tasks:
    ```javascript title="JavaScript Query"
    const tasks = await Task.findAll({ where: { status: 'pending' } })
    // Returns: [{ id: 1, title: 'Buy groceries', status: 'pending' }]
    ```
  - API: Maps to `POST /v1/tasks` or `GET /v1/tasks?status=pending`.

- **Common ORM Frameworks**:
  - **Python**: Django ORM, SQLAlchemy.
  - **JavaScript**: Sequelize, TypeORM.
  - **Java**: Hibernate.
  - **Ruby**: ActiveRecord (Rails).
- **Use Cases**:
  - Simplifying database operations in a TODO service API (e.g., creating or fetching tasks).
  - Managing complex relationships (e.g., tasks linked to users via foreign keys).
  - Rapid application development with less focus on SQL.
- **Benefits**:
  - **Productivity**: Reduces boilerplate SQL code, allowing focus on application logic.
  - **Abstraction**: Shields developers from database-specific SQL syntax.
  - **Portability**: Works across different databases (e.g., MySQL, PostgreSQL) with minimal code changes.
  - **Security**: Helps prevent SQL injection by using parameterized queries.
- **Challenges**:
  - **Performance**: Generated queries may be less optimized than hand-written SQL.
  - **Learning Curve**: Requires understanding the ORM’s conventions and limitations.
  - **Abstraction Overhead**: Can hide database details, making complex queries harder to optimize.
  - **Limited Flexibility**: May not support all database-specific features.
- **Contrast with Raw SQL**:
  - **ORM**: Object-oriented, abstracts SQL, easier for simple CRUD but less control.
  - **Raw SQL**: Direct database queries, more control but requires manual query writing.

In backend development, an ORM is critical for a TODO service to streamline database interactions for APIs (e.g., `GET /v1/tasks`), enabling developers to manage tasks and users efficiently while maintaining clean, maintainable code, though it requires careful optimization for complex or high-performance scenarios.

## Conclusion

This series of 100 basic backend interview questions provides a comprehensive foundation for understanding key concepts essential for backend development roles. Covering topics such as HTTP methods, database fundamentals, networking, security, concurrency, APIs, and system architecture, these questions span critical areas like REST, SQL, NoSQL, and version control. Each question, from the role of a backend server to the intricacies of database normalization and synchronization mechanisms, is designed to prepare candidates for discussing core backend principles concisely and effectively. Whether you're preparing for a backend developer interview or seeking to solidify your knowledge, this series offers a structured starting point to grasp the essentials of building robust, scalable, and secure backend systems, such as those powering a TODO service API.
