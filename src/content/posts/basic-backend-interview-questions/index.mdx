---
title: '100 Basic Backend Interview Questions'
description: 'Fundamentals, Databases, Networking, Security, Performance. This article covers the most common basic interview questions for backend developers.'
pubDate: 2025-08-16
author: 'Xeost'
# cover: assets/cover.png
recommend: false
tags: ['Interview Q&A', 'Backend']
---

This is a list of 100 language-agnostic basic backend interview questions for Backend developers. It covers the most common interview questions for backend developers, including fundamentals, databases, networking, security, and performance.

## Fundamentals

### What is the role of a backend server in a web application?

A backend server in a web application handles the server-side logic, processing requests from the frontend, managing data, and ensuring the application runs smoothly. It performs tasks like:

- **Data Management**: Interacts with databases to store, retrieve, update, or delete data.
- **Business Logic**: Executes the core functionality of the application, such as calculations, workflows, or rules.
- **API Handling**: Processes API requests and sends responses to the frontend or other clients.
- **Authentication/Authorization**: Manages user login, sessions, and access control.
- **Communication**: Facilitates interaction between the frontend, databases, and external services.
- **Performance & Scalability**: Handles load balancing, caching, and scaling to ensure reliability and speed.

In short, the backend server powers the application's functionality, acting as the backbone that supports the user interface and data flow.

### What is an API?

An API (Application Programming Interface) is a set of rules and tools that allows different software applications to communicate with each other. It acts as an intermediary, enabling the exchange of data or functionality between systems, such as a backend server and a frontend client, by defining standardized methods for requests and responses (e.g., GET, POST). For example, a backend API might provide data like user profiles or process actions like payments, which the frontend can access without needing to understand the backend's internal logic.

> [!important]+ **Example**: A simple To-Do List API
>
> **Base URL**: `https://api.todo-service.com/v1`
>
> - **GET** `/tasks` - Get all tasks
> - **GET** `/tasks/{id}` - Get a task by ID
> - **POST** `/tasks` - Create a new task
> - **PUT** `/tasks/{id}` - Update a task by ID
> - **DELETE** `/tasks/{id}` - Delete a task by ID

### What is the difference between frontend and backend development?

**Frontend Development**:

- Focuses on the user-facing part of a web application.
- Involves building the interface, visuals, and user interactions (e.g., buttons, forms, layouts).
- Uses technologies like HTML, CSS, JavaScript, and frameworks like React or Vue.js.
- Runs in the user's browser, handling client-side logic and rendering.
- Goal: Create an intuitive, responsive, and visually appealing user experience.

**Backend Development**:

- Focuses on the server-side logic, data management, and application functionality.
- Involves handling requests, processing data, managing databases, and ensuring system reliability.
- Uses technologies like Python, Java, Node.js, and databases like MySQL or MongoDB.
- Runs on the server, managing APIs, authentication, and business logic.
- Goal: Ensure the application is secure, scalable, and efficiently processes data.

**Key Difference**: Frontend is about what users see and interact with in the browser; backend is about the behind-the-scenes logic, data, and server operations that power the application.

### What is a server?

A **server** is a computer or software system that provides resources, services, or data to other computers (clients) over a network. In the context of a web application, it handles backend tasks such as processing requests, managing databases, executing business logic, and sending responses to clients (e.g., browsers or apps). Servers can be physical machines or virtual instances running software like Apache, Nginx, or Node.js, and they operate continuously to ensure availability and reliability of services.

### What is a request-response cycle?

The **request-response cycle** is the process in which a client (e.g., a web browser or app) communicates with a server to request resources or services, and the server processes the request and sends back a response.

**Steps in the Cycle**:

1. **Request**: The client sends an HTTP request to the server, specifying an action (e.g., GET, POST) and a resource (e.g., `/tasks`).
2. **Processing**: The server receives the request, processes it (e.g., retrieves data, performs logic, or updates a database), and prepares a response.
3. **Response**: The server sends back an HTTP response, typically containing data (e.g., JSON, HTML) or a status (e.g., 200 OK, 404 Not Found).

**Example**:

- A user clicks a link in a browser (client) to view a webpage (`GET /home`).
- The server processes the request, fetches the webpage content, and sends it back.
- The browser renders the response for the user to see.

This cycle is the foundation of client-server communication in web applications.

### What is HTTP?

HTTP (HyperText Transfer Protocol) is a protocol used for communication between clients (e.g., web browsers) and servers over the internet. It defines how requests and responses are structured and transmitted, enabling the retrieval of resources like web pages, images, or APIs.

Key points:

- **Stateless**: Each request-response cycle is independent.
- **Methods**: Includes actions like GET (retrieve data), POST (send data), PUT (update data), and DELETE (remove data).
- **Structure**: Requests contain headers, methods, and URLs; responses include status codes (e.g., 200 OK, 404 Not Found) and data.
- **Port**: Typically uses port 80 (or 443 for HTTPS).

HTTP is the foundation for data exchange in web applications.

### What are HTTP methods?

HTTP methods are standardized actions that define the type of operation a client (e.g., a browser or app) wants to perform on a server's resource (e.g., a webpage, API endpoint). They are part of the HTTP protocol and indicate the intended action in a request-response cycle. Below are the most common HTTP methods:

1. **GET**: Retrieve a resource or data from the server (e.g., fetch a webpage or list of tasks).
2. **POST**: Send data to the server to create a new resource (e.g., submit a form or create a new task).
3. **PUT**: Update an existing resource on the server (e.g., modify a task's details).
4. **DELETE**: Remove a resource from the server (e.g., delete a task).
5. **PATCH**: Partially update a resource (e.g., change only the status of a task).
6. **HEAD**: Retrieve metadata (headers) about a resource without the body, similar to GET.
7. **OPTIONS**: Query the server for supported HTTP methods or communication options.
8. **TRACE**: Echo the received request for debugging purposes (rarely used).
9. **CONNECT**: Establish a tunnel to the server, typically for proxying (e.g., for HTTPS).

Each method is used in specific contexts to interact with resources in a predictable and standardized way, forming the backbone of RESTful APIs and web communication.

### What is a URL?

A **URL** (Uniform Resource Locator) is a string that specifies the address of a resource on the internet, such as a webpage, file, or API endpoint. It provides a standardized way to locate and access resources over a network, typically via HTTP/HTTPS.

**Components of a URL**:

- **Scheme**: The protocol used (e.g., `http`, `https`).
- **Host**: The domain name or IP address of the server (e.g., `example.com`).
- **Port** (optional): The port number for the connection (e.g., `:80` for HTTP, often omitted).
- **Path**: The specific resource or endpoint on the server (e.g., `/tasks`).
- **Query Parameters** (optional): Key-value pairs for additional data (e.g., `?id=123`).
- **Fragment** (optional): A reference to a specific part of the resource (e.g., `#section1`).

**Example**:

`https://api.todo-service.com:443/v1/tasks?id=123#details`

- Scheme: `https`
- Host: `api.todo-service.com`
- Port: `443`
- Path: `/v1/tasks`
- Query: `id=123`
- Fragment: `details`

A URL acts as a precise address for accessing resources in web applications.

### What is a URI?

A **URI** (Uniform Resource Identifier) is a string that uniquely identifies a resource, either on the internet or within a system. It serves as a general way to reference resources, encompassing both **URLs** (Uniform Resource Locators) and **URNs** (Uniform Resource Names).

**Key Points**:

- **Purpose**: Identifies a resource by name, location, or both.
- **Types**:
  - **URL**: Specifies the location and how to access a resource (e.g., `https://api.todo-service.com/v1/tasks`).
  - **URN**: Identifies a resource by name without specifying its location (e.g., `urn:isbn:1234567890`).
- **Components** (for URLs, a subset of URIs):
  - Scheme (e.g., `https`, `ftp`).
  - Authority (e.g., domain like `example.com`).
  - Path (e.g., `/v1/tasks`).
  - Query (e.g., `?id=123`).
  - Fragment (e.g., `#section`).
- **Difference from URL**: All URLs are URIs, but not all URIs are URLs (e.g., URNs are URIs but don’t specify a location).

**Example**:

- URI (URL): `https://api.todo-service.com/v1/tasks?id=123`
- URI (URN): `urn:uuid:6e8bc430-9c3a-11d9-9669-0800200c9a66`

In backend development, URIs are used to define endpoints or resources in APIs and systems.

### What is FQDN?

An **FQDN** (Fully Qualified Domain Name) is the complete address of a specific resource on the internet, uniquely identifying a host within the domain name system (DNS). It includes the hostname and all domain levels, providing an absolute path to the resource.

**Key Points**:

- **Structure**: Consists of the hostname, subdomain (if any), second-level domain, and top-level domain (e.g., `api.todo-service.com`).
- **Purpose**: Used to locate servers or resources precisely in networking and web applications.
- **Example**:
  - `api.todo-service.com` is an FQDN, where:
    - `api` is the hostname.
    - `todo-service` is the second-level domain.
    - `com` is the top-level domain.
  - In contrast, `todo-service.com` is a domain name but not fully qualified without the hostname.
- **Usage in Backend**: FQDNs are used in DNS resolution, server configuration, APIs, and networking (e.g., specifying a server in a URL like `https://api.todo-service.com/v1/tasks`).

An FQDN ensures unambiguous identification of a resource across the internet.

### What is an endpoint in an API?

An **endpoint** in an API is a specific address (URL) that represents a resource or function in a web service, allowing clients to interact with the server by sending requests to perform actions like retrieving, creating, updating, or deleting data. Each endpoint is tied to a specific HTTP method (e.g., GET, POST) and path.

**Key Points**:

- **Structure**: Typically consists of a base URL and a path (e.g., `https://api.todo-service.com/v1/tasks`).
- **Purpose**: Defines a point of interaction for a specific operation (e.g., `GET /tasks` to list tasks or `POST /tasks` to create a task).
- **Example** (from a TODO service):
  - `GET /v1/tasks` - Retrieves all tasks.
  - `POST /v1/tasks` - Creates a new task.
  - `DELETE /v1/tasks/{id}` - Deletes a task by ID.

In backend development, endpoints are designed to handle specific client requests and return appropriate responses, forming the core of API functionality.

## Databases

### What is a database?

A **database** is an organized collection of data, typically stored and managed electronically on a computer system, designed to allow efficient storage, retrieval, updating, and deletion of data. In the context of backend development, it serves as a structured repository to store application data, such as user information, transactions, or content.

**Key Points**:

- **Purpose**: Enables persistent storage and management of data for applications.
- **Types**:
  - **Relational Databases**: Use tables with rows and columns (e.g., MySQL, PostgreSQL), managed with SQL.
  - **NoSQL Databases**: Handle unstructured or semi-structured data (e.g., MongoDB for documents, Redis for key-value stores).
- **Components**: Consists of tables (in relational databases), collections (in NoSQL), or other data structures, with mechanisms for querying and indexing.
- **Backend Role**: The backend interacts with the database to perform CRUD operations (Create, Read, Update, Delete) via APIs or direct queries.

For example, in a TODO service, a database might store tasks with fields like `id`, `title`, and `status`.

### What is SQL?

**SQL** (Structured Query Language) is a standardized programming language used to manage and manipulate relational databases. It enables users to perform operations such as querying, inserting, updating, and deleting data, as well as defining and managing database structures.

**Key Points**:

- **Purpose**: Interacts with relational databases to retrieve and manage data.
- **Common Operations**:
  - **SELECT**: Retrieve data (e.g., `SELECT * FROM tasks WHERE status = 'pending'`).
  - **INSERT**: Add data (e.g., `INSERT INTO tasks (title) VALUES ('New Task')`).
  - **UPDATE**: Modify data (e.g., `UPDATE tasks SET status = 'completed' WHERE id = 1`).
  - **DELETE**: Remove data (e.g., `DELETE FROM tasks WHERE id = 1`).
- **Additional Functions**: Defines schemas (e.g., creating tables), manages permissions, and supports joins for combining data across tables.
- **Used With**: Relational databases like MySQL, PostgreSQL, SQLite, or Oracle.

In backend development, SQL is used to interact with databases to support application logic, such as fetching or updating tasks in a TODO service.

### What is a primary key?

A **primary key** is a unique identifier for each record in a relational database table. It ensures that every row can be uniquely distinguished and is used to enforce data integrity and enable efficient data retrieval.

**Key Points**:

- **Uniqueness**: No two records in the table can have the same primary key value.
- **Non-null**: A primary key cannot contain null values.
- **Purpose**: Facilitates indexing, searching, and linking tables via foreign keys.
- **Example**: In a TODO service table `tasks`, a column `id` (e.g., `1`, `2`, `3`) can serve as the primary key to uniquely identify each task.
- **Implementation**: Typically an auto-incrementing integer or a unique string (e.g., UUID).

In backend development, primary keys are critical for database operations like querying or joining tables.

### What is a foreign key?

A **foreign key** is a column (or set of columns) in a relational database table that establishes a link between data in two tables. It references the primary key (or a unique key) of another table, ensuring referential integrity by enforcing that the value in the foreign key column matches an existing value in the referenced table's primary key or unique key.

**Key Points**:

- **Purpose**: Maintains relationships between tables, enabling data consistency and relational queries (e.g., joins).
- **Constraints**: Ensures the foreign key value exists in the referenced table or is null (if allowed).
- **Example**: In a TODO service:
  - Table `tasks`: Has columns `task_id` (primary key) and `title`.
  - Table `users`: Has columns `user_id` (primary key) and `name`.
  - Table `tasks` may have a `user_id` column as a foreign key referencing `users.user_id`, linking each task to a specific user.
- **Behavior**: Can enforce rules like cascading deletes/updates (e.g., if a user is deleted, their tasks are also deleted).

In backend development, foreign keys are used to model relationships and ensure data integrity across related tables.

### What is a table in a database?

A **table** in a database is a structured collection of data organized into rows and columns, used to store related information in a relational database. Each table represents a specific entity or concept (e.g., users, tasks) and is defined by a schema that specifies its columns and their data types.

**Key Points**:

- **Columns**: Define the attributes of the entity (e.g., `id`, `title`, `status` in a `tasks` table).
- **Rows**: Represent individual records or instances of the entity (e.g., a single task with values `1`, `"Buy groceries"`, `"pending"`).
- **Primary Key**: A unique column (or set of columns) to identify each row (e.g., `id`).
- **Purpose**: Organizes data for efficient storage, retrieval, and manipulation using queries (e.g., SQL).
- **Example**: In a TODO service, a `tasks` table might have columns `task_id` (primary key), `title`, `description`, and `due_date`.

In backend development, tables are fundamental for storing and managing application data, enabling operations like CRUD (Create, Read, Update, Delete).

### What is a row in a database?

A **row** in a database is a single record or entry in a relational database table that represents one instance of the entity defined by the table. Each row contains values for the columns defined in the table's schema, corresponding to the attributes of that entity.

**Key Points**:

- **Structure**: A row consists of data for each column in the table (e.g., for a `tasks` table with columns `task_id`, `title`, `status`, a row might be `1, "Buy groceries", "pending"`).
- **Uniqueness**: Typically identified by a primary key (e.g., `task_id`).
- **Purpose**: Stores a complete set of data for a single entity instance, such as one task in a TODO service.
- **Example**: In a `tasks` table:
  - Columns: `task_id`, `title`, `due_date`, `status`
  - Row: `1, "Complete project", "2025-10-01", "pending"`

In backend development, rows are manipulated through SQL queries (e.g., SELECT, INSERT, UPDATE, DELETE) to manage individual records in a database.

### What is a column in a database?

A **column** in a database is a single attribute or field in a relational database table that defines a specific type of data stored for each record (row) in that table. It represents a particular property of the entity the table describes.

**Key Points**:

- **Structure**: Each column has a name and a defined data type (e.g., integer, string, date) that specifies what kind of data it can hold.
- **Purpose**: Organizes data by categorizing it into specific attributes for all records in the table.
- **Example**: In a `tasks` table for a TODO service:
  - Columns: `task_id` (integer), `title` (string), `due_date` (date), `status` (string).
  - A row might contain: `1, "Buy groceries", "2025-10-01", "pending"`, where each value corresponds to a column.
- **Constraints**: Columns can have rules like `NOT NULL`, unique, or foreign key constraints to ensure data integrity.

In backend development, columns define the structure of the data stored in a table and are used in SQL queries to retrieve or manipulate specific attributes.

### What is CRUD?

**CRUD** stands for **Create, Read, Update, Delete**, representing the four fundamental operations used to manage data in a database or application. These operations are essential for interacting with persistent storage in backend development.

**Key Points**:

- **Create**: Adds new data to the database (e.g., inserting a new task in a TODO service).
  - Example: `INSERT INTO tasks (title, status) VALUES ('New Task', 'pending')`
- **Read**: Retrieves or queries data from the database (e.g., fetching a list of tasks).
  - Example: `SELECT * FROM tasks WHERE status = 'pending'`
- **Update**: Modifies existing data in the database (e.g., changing a task’s status).
  - Example: `UPDATE tasks SET status = 'completed' WHERE task_id = 1`
- **Delete**: Removes data from the database (e.g., deleting a task).
  - Example: `DELETE FROM tasks WHERE task_id = 1`

**Context**:

- **Backend Role**: CRUD operations are typically implemented in APIs (e.g., REST endpoints like `POST /tasks`, `GET /tasks`, `PUT /tasks/{id}`, `DELETE /tasks/{id}`).
- **Purpose**: Provides a standardized way to manage data, ensuring applications can store, retrieve, modify, and remove records efficiently.

In a TODO service, CRUD enables users to create tasks, view them, update their details, and delete them as needed.

### What is a query?

A **query** in a database is a request for data or instructions to retrieve, manipulate, or manage information stored in a database, typically written in a query language like SQL for relational databases. It specifies what data to access or how to modify it based on defined criteria.

**Key Points**:

- **Purpose**: Queries allow users or applications to interact with a database to perform operations like retrieving, inserting, updating, or deleting data (aligned with CRUD operations).
- **Types** (in SQL):
  - **SELECT**: Retrieves data (e.g., `SELECT title, status FROM tasks WHERE status = 'pending'`).
  - **INSERT**: Adds new data (e.g., `INSERT INTO tasks (title) VALUES ('New Task')`).
  - **UPDATE**: Modifies data (e.g., `UPDATE tasks SET status = 'completed' WHERE task_id = 1`).
  - **DELETE**: Removes data (e.g., `DELETE FROM tasks WHERE task_id = 1`).
- **Components**: Queries often include clauses like `WHERE` (filtering), `ORDER BY` (sorting), `JOIN` (combining tables), and `GROUP BY` (aggregating data).
- **Example**: In a TODO service, a query like `SELECT * FROM tasks WHERE due_date = '2025-10-01'` retrieves all tasks due on a specific date.

In backend development, queries are used to fetch or manipulate data in response to API requests or application logic, enabling dynamic interaction with the database.

### What is normalization?

**Normalization** is the process of organizing data in a relational database to eliminate redundancy, improve data integrity, and ensure efficient storage and retrieval. It involves structuring tables and their relationships according to a set of rules, called normal forms, to minimize data anomalies during CRUD operations (Create, Read, Update, Delete).

**Key Points**:

- **Purpose**: Reduces data duplication, ensures consistency, and simplifies maintenance.
- **Normal Forms** (simplified):
  - **1NF (First Normal Form)**: Ensures all columns contain atomic (indivisible) values and each record is unique (no duplicate rows).
  - **2NF**: Meets 1NF and ensures non-key columns are fully dependent on the primary key (eliminates partial dependencies).
  - **3NF**: Meets 2NF and ensures non-key columns are not dependent on other non-key columns (eliminates transitive dependencies).
- **Example**: In a TODO service:
  - Unnormalized table: A `tasks` table with columns `task_id`, `title`, `user_name`, `user_email` might repeat `user_name` and `user_email` for tasks by the same user.
  - Normalized:
    - `tasks` table: `task_id`, `title`, `user_id` (foreign key).
    - `users` table: `user_id`, `user_name`, `user_email`.
    - This splits user data into a separate table, reducing redundancy.
- **Benefits**: Saves storage space, ensures data consistency, and simplifies updates.
- **Trade-offs**: May increase query complexity (e.g., requiring joins) and impact performance for read-heavy applications.

In backend development, normalization is critical for designing efficient and maintainable database schemas, especially for applications like a TODO service where tasks and user data need clear relationships.

## Networking

### What is TCP?

**TCP** (Transmission Control Protocol) is a standard communication protocol used in computer networks to ensure reliable, ordered, and error-checked data transmission between devices over the internet or other networks. It operates at the transport layer of the OSI model and is a core component of the internet protocol suite (TCP/IP).

**Key Points**:

- **Reliability**: Guarantees delivery of data packets in the correct order without loss or duplication by using acknowledgments, retransmissions, and error detection.
- **Connection-Oriented**: Establishes a connection between sender and receiver via a three-way handshake (SYN, SYN-ACK, ACK) before data transfer and closes it afterward.
- **Flow Control**: Manages data flow to prevent overwhelming the receiver using mechanisms like sliding windows.
- **Error Handling**: Detects and corrects errors through checksums and retransmits lost packets.
- **Use Cases**: Used in applications requiring reliable data transfer, such as web browsing (HTTP/HTTPS), email (SMTP), and file transfers (FTP).
- **Example**: In a TODO service, when a client sends a `POST` request to `https://api.todo-service.com/v1/tasks` to create a task, TCP ensures the request and response data are delivered accurately and in sequence.

In backend development, TCP underpins reliable communication between clients and servers, ensuring API requests and responses are transmitted correctly.

### What is UDP?

**UDP** (User Datagram Protocol) is a lightweight communication protocol used in computer networks for transmitting data between devices. It operates at the transport layer of the OSI model, like TCP, but is designed for speed and efficiency rather than reliability.

**Key Points**:

- **Connectionless**: Does not establish a connection before sending data, unlike TCP's three-way handshake.
- **Unreliable**: Does not guarantee delivery, order, or error correction; packets may be lost, duplicated, or arrive out of sequence.
- **Low Overhead**: Minimal header size and no retransmission or flow control, making it faster than TCP.
- **Use Cases**: Ideal for applications where speed is critical and occasional data loss is acceptable, such as:
  - Real-time applications (e.g., video streaming, online gaming).
  - DNS queries.
  - VoIP (e.g., Zoom or Skype calls).
- **Example**: In a TODO service, UDP might be used for a real-time feature like broadcasting task updates to multiple clients, where low latency is prioritized over guaranteed delivery.

In backend development, UDP is used when performance is more critical than reliability, unlike TCP, which ensures accurate data transfer.

### What is IP?

**IP** (Internet Protocol) is a fundamental protocol in the internet protocol suite that enables communication between devices across networks, such as the internet or local networks. It operates at the network layer of the OSI model and is responsible for addressing and routing data packets from a source to a destination.

**Key Points**:

- **Purpose**: Defines how data packets are formatted, addressed, transmitted, and routed across networks.
- **Addressing**: Assigns unique IP addresses to devices to identify them (e.g., `192.168.1.1` for IPv4 or `2001:db8::1` for IPv6).
- **Versions**:
  - **IPv4**: Uses 32-bit addresses (e.g., `192.168.0.1`), limited to ~4.3 billion unique addresses.
  - **IPv6**: Uses 128-bit addresses (e.g., `2001:0db8:85a3::8a2e:0370:7334`), designed to handle more devices.
- **Functions**:
  - **Packet Routing**: Directs packets through routers to reach the destination IP address.
  - **Fragmentation**: Breaks data into smaller packets for transmission and reassembles them if needed.
- **Connectionless**: Sends packets independently without establishing a connection (unlike TCP).
- **Example**: In a TODO service, when a client sends a request to `https://api.todo-service.com/v1/tasks`, the IP protocol routes the request to the server’s IP address (e.g., `93.184.216.34`).

In backend development, IP ensures data packets reach the correct server or client, forming the foundation for protocols like TCP and UDP to handle reliable or fast communication.

### What is a port?

A **port** is a virtual point in a computer’s networking system used to identify specific processes or services on a device, allowing multiple applications to communicate over a network simultaneously. It is a 16-bit number (0 to 65535) associated with an IP address to direct data to the correct application or service.

**Key Points**:

- **Purpose**: Differentiates between different services or applications running on the same device, enabling targeted data delivery.
- **Types**:
  - **Well-Known Ports** (0–1023): Reserved for common services (e.g., port 80 for HTTP, 443 for HTTPS, 22 for SSH).
  - **Registered Ports** (1024–49151): Used for specific applications or services.
  - **Dynamic/Private Ports** (49152–65535): Temporarily assigned for client-side connections.
- **How It Works**: Combines with an IP address to form a complete network address (e.g., `192.168.1.1:80` specifies HTTP traffic to a server at that IP).
- **Example**: In a TODO service, a client sending a request to `https://api.todo-service.com:443/v1/tasks` uses port 443 (HTTPS) to communicate with the server’s web service, while the server might use port 3306 internally for MySQL database connections.

In backend development, ports are critical for routing network traffic to the appropriate application or service, ensuring proper communication between clients and servers.

### What is DNS?

**DNS** (Domain Name System) is a protocol and distributed system that translates human-readable domain names (e.g., `api.todo-service.com`) into machine-readable IP addresses (e.g., `93.184.216.34`) to locate devices or services on a network, such as the internet.

**Key Points**:

- **Purpose**: Acts like a phonebook for the internet, mapping domain names to IP addresses so clients can access servers without needing to know their numeric addresses.
- **How It Works**:
  - A client (e.g., a browser) sends a DNS query to a DNS resolver.
  - The resolver contacts DNS servers (e.g., root, TLD, and authoritative servers) to find the corresponding IP address.
  - The IP address is returned, allowing the client to connect to the server.
- **Components**:
  - **Domain Name**: Hierarchical name (e.g., `subdomain.example.com`).
  - **DNS Resolver**: A server that processes DNS queries.
  - **DNS Records**: Data types like A (IPv4 address), AAAA (IPv6), CNAME (alias), or MX (mail server).
- **Example**: In a TODO service, when a client accesses `https://api.todo-service.com/v1/tasks`, DNS resolves `api.todo-service.com` to an IP address like `192.168.1.1` to locate the server.
- **Port Usage**: DNS typically uses port 53 for queries (often over UDP for speed, sometimes TCP for larger responses).

In backend development, DNS is critical for enabling clients to find and connect to servers hosting APIs or web services using domain names.

### What is a socket?

A **socket** is an endpoint for communication between two devices (e.g., a client and a server) over a network. It is a software interface that enables data exchange using protocols like TCP or UDP, combining an IP address and a port number to identify a specific process or service on a device.

**Key Points**:

- **Purpose**: Facilitates bidirectional communication, allowing applications to send and receive data across networks (e.g., the internet).
- **Components**: A socket is defined by:
  - **IP Address**: Identifies the device (e.g., `192.168.1.1`).
  - **Port Number**: Identifies the specific application or service (e.g., `443` for HTTPS).
  - **Protocol**: TCP (reliable, connection-oriented) or UDP (fast, connectionless).
- **Types**:
  - **Stream Sockets**: Use TCP for reliable, ordered data transfer (e.g., HTTP requests).
  - **Datagram Sockets**: Use UDP for faster, unreliable data transfer (e.g., streaming).
- **Example**: In a TODO service, when a client sends a request to `https://api.todo-service.com:443/v1/tasks`, a socket is created on the client (e.g., `192.168.1.100:49152`) and server (e.g., `93.184.216.34:443`) to handle the HTTP communication over TCP.
- **Backend Role**: Servers listen on sockets (e.g., port 80 or 443) to accept incoming client connections, while clients create sockets to initiate requests.

In backend development, sockets are fundamental for enabling network communication, such as handling API requests or real-time data exchange (e.g., WebSockets for live updates).

### What is latency?

**Latency** is the time delay between a client's request and the server's response in a network or system. It measures how long it takes for data to travel from one point to another or for a system to process a request.

**Key Points**:

- **Definition**: The duration (usually in milliseconds) from initiating an action (e.g., sending an HTTP request) to receiving the first response.
- **Causes**:
  - Network delays (e.g., distance, routing, or congestion).
  - Server processing time (e.g., database queries, computation).
  - Application inefficiencies (e.g., unoptimized code).
- **Example**: In a TODO service, if a client sends a `GET /tasks` request to `https://api.todo-service.com`, latency is the time from sending the request to receiving the first byte of the response (e.g., 50ms for a fast server, 500ms for a distant or slow one).
- **Impact**: High latency can degrade user experience, especially in real-time applications like video calls or interactive APIs.
- **Measurement**: Often measured as round-trip time (RTT) in networking or response time in APIs.

In backend development, minimizing latency is critical for performance, achieved through optimizations like caching, efficient database queries, or using content delivery networks (CDNs).

### What is bandwidth?

**Bandwidth** is the maximum rate at which data can be transferred over a network connection, typically measured in bits per second (bps), such as Mbps (megabits per second) or Gbps (gigabits per second). It represents the capacity of a network link to handle data traffic.

**Key Points**:

- **Definition**: The volume of data that can be transmitted in a given time, akin to the width of a pipe for data flow.
- **Factors Affecting Bandwidth**:
  - Network infrastructure (e.g., fiber vs. copper cables).
  - Network congestion or shared usage.
  - Hardware limitations (e.g., routers, network cards).
- **Example**: In a TODO service, if a server has a bandwidth of 100 Mbps, it can theoretically handle 100 megabits of data per second for API requests and responses (e.g., sending large lists of tasks or media files).
- **Difference from Latency**: Bandwidth is about capacity (how much data), while latency is about speed (how fast data travels).
- **Impact**: Low bandwidth can lead to slow data transfers, especially for large payloads, affecting user experience in high-traffic applications.

In backend development, bandwidth is critical for ensuring servers can handle multiple client requests efficiently, especially for data-intensive operations like streaming or bulk API responses.

### What is a firewall?

A **firewall** is a network security device or software that monitors and controls incoming and outgoing network traffic based on predefined security rules. It acts as a barrier between a trusted internal network and untrusted external networks (e.g., the internet) to protect systems from unauthorized access and threats.

**Key Points**:

- **Purpose**: Filters traffic to prevent malicious activities, such as hacking, malware, or unauthorized data access.
- **How It Works**: Examines packets (data units) and allows, blocks, or redirects them based on rules (e.g., IP addresses, ports, protocols).
- **Types**:
  - **Hardware Firewall**: Physical device between networks (e.g., a router with firewall capabilities).
  - **Software Firewall**: Runs on a server or device (e.g., Windows Defender Firewall).
  - **Network-Based**: Protects entire networks (e.g., enterprise firewalls).
  - **Host-Based**: Protects individual devices.
- **Rules Examples**:
  - Allow `HTTPS` traffic on port 443.
  - Block incoming traffic from a specific IP address.
- **Example**: In a TODO service, a firewall might allow `GET /tasks` requests to `https://api.todo-service.com:443` only from trusted IP ranges and block suspicious traffic to prevent attacks like DDoS.
- **Advanced Features**: Can include intrusion detection, VPN support, or deep packet inspection.

In backend development, firewalls are critical for securing servers hosting APIs or databases, ensuring only legitimate traffic reaches the application.

### What is NAT?

**NAT** (Network Address Translation) is a technique used in networking to map one IP address space to another by modifying network address information in the IP header of packets while they are in transit. It is typically implemented in routers or firewalls to manage IP address allocation and enable communication between networks, especially when private IP addresses are used.

**Key Points**:

- **Purpose**: Allows multiple devices on a private network (e.g., home or office) to share a single public IP address for accessing external networks (e.g., the internet).
- **How It Works**:
  - Translates private IP addresses (e.g., `192.168.1.10`) to a public IP address (e.g., `203.0.113.1`) for outgoing traffic.
  - Maintains a translation table to route responses back to the correct private IP and port.
- **Types**:
  - **Static NAT**: Maps a private IP to a specific public IP (one-to-one).
  - **Dynamic NAT**: Maps private IPs to a pool of public IPs (temporary assignments).
  - **PAT (Port Address Translation)**: Maps multiple private IPs to a single public IP using different port numbers (most common, also called NAT overload).
- **Example**: In a TODO service, a server behind a NAT-enabled router with a private IP (`192.168.1.100`) sends API responses to clients on the internet via a public IP (`93.184.216.34`). The router uses NAT to translate the private IP to the public IP and tracks the connection using ports.
- **Benefits**:
  - Conserves public IP addresses.
  - Provides a layer of security by hiding internal network structures.
- **Drawbacks**: Can complicate direct inbound connections (e.g., peer-to-peer apps) unless configured with port forwarding.

In backend development, NAT is critical for managing server connectivity in private networks, enabling APIs or services to communicate with external clients while maintaining security and efficient IP usage.

## Security

### What is authentication?

**Authentication** is the process of verifying the identity of a user, device, or system attempting to access a resource or application. It ensures that the entity making a request is who or what it claims to be.

**Key Points**:

- **Purpose**: Confirms identity to prevent unauthorized access to sensitive resources (e.g., APIs, databases).
- **Common Methods**:
  - **Password-Based**: User provides a username and password (e.g., logging into a TODO service).
  - **Token-Based**: Uses tokens like JWT (JSON Web Tokens) or API keys for programmatic access.
  - **Multi-Factor Authentication (MFA)**: Combines multiple credentials (e.g., password + SMS code).
  - **OAuth**: Delegates authentication to a third-party provider (e.g., "Login with Google").
  - **Biometrics**: Uses fingerprints or facial recognition.
- **Example**: In a TODO service, when a user logs in with an email and password to access `https://api.todo-service.com/v1/tasks`, the backend verifies the credentials against a stored user database before granting access.
- **Outcome**: Successful authentication typically results in a session, token, or access grant, allowing the user to interact with protected resources.

In backend development, authentication is critical for securing APIs and ensuring only authorized users can perform actions like creating or viewing tasks.

### What is authorization?

**Authorization** is the process of determining whether an authenticated user, device, or system has permission to access specific resources or perform certain actions within an application or system. It occurs after authentication and focuses on what the entity is allowed to do.

**Key Points**:

- **Purpose**: Enforces access control to ensure users or systems only interact with resources or operations they are permitted to access.
- **How It Works**: The system checks the authenticated entity's permissions or roles against predefined rules or policies.
- **Common Methods**:
  - **Role-Based Access Control (RBAC)**: Permissions are assigned based on roles (e.g., admin, user).
  - **Attribute-Based Access Control (ABAC)**: Permissions are based on attributes (e.g., user location, department).
  - **Access Control Lists (ACLs)**: Define specific permissions for individual users or groups.
- **Example**: In a TODO service:
  - After authentication, a user might be authorized to view their own tasks (`GET /v1/tasks`) but not another user’s tasks.
  - An admin might be authorized to delete any task (`DELETE /v1/tasks/{id}`), while a regular user cannot.
- **Difference from Authentication**:
  - Authentication verifies _who_ you are (e.g., valid login credentials).
  - Authorization determines _what_ you can do (e.g., read or modify specific data).

In backend development, authorization is critical for securing APIs and ensuring users or clients only access resources or perform actions within their permitted scope, protecting data integrity and privacy.

### What is encryption?

**Encryption** is the process of converting readable data (plaintext) into an unreadable format (ciphertext) using an algorithm and a key to protect its confidentiality. It ensures that only authorized parties with the correct key can decrypt and access the original data.

**Key Points**:

- **Purpose**: Secures sensitive data during storage or transmission to prevent unauthorized access, interception, or tampering.
- **Types**:
  - **Symmetric Encryption**: Uses the same key for encryption and decryption (e.g., AES). Fast but requires secure key sharing.
  - **Asymmetric Encryption**: Uses a pair of keys (public and private) for encryption and decryption (e.g., RSA). Slower but secure for key exchange.
- **Use Cases**:
  - Protecting data in transit (e.g., HTTPS for API requests in a TODO service).
  - Securing stored data (e.g., encrypting user passwords in a database).
  - Ensuring secure communication (e.g., SSL/TLS for web servers).
- **Example**: In a TODO service, when a client sends a `POST /v1/tasks` request over HTTPS, the data (e.g., task details) is encrypted using TLS to prevent eavesdropping during transmission.
- **Components**:
  - **Plaintext**: Original data (e.g., "Create new task").
  - **Ciphertext**: Encrypted data (e.g., "X7aP9qZ...").
  - **Key**: Secret used to encrypt/decrypt (e.g., a 256-bit AES key).
  - **Algorithm**: Mathematical process (e.g., AES, RSA).

In backend development, encryption is critical for securing sensitive data, such as user credentials or API payloads, ensuring privacy and compliance with security standards.

### What is HTTPS?

**HTTPS** (HyperText Transfer Protocol Secure) is an extension of HTTP that uses encryption to secure communication between a client (e.g., a web browser or app) and a server over a network, typically the internet. It ensures data privacy, integrity, and authentication.

**Key Points**:

- **Purpose**: Protects data in transit from eavesdropping, tampering, or interception by encrypting it with protocols like TLS (Transport Layer Security) or its predecessor, SSL (Secure Sockets Layer).
- **How It Works**:
  - Uses **TLS/SSL** to encrypt HTTP requests and responses.
  - Authenticates the server using digital certificates issued by trusted Certificate Authorities (CAs).
  - Establishes a secure connection via a handshake process, ensuring only the client and server can read the data.
- **Key Features**:
  - **Encryption**: Scrambles data (e.g., API payloads) to prevent unauthorized access.
  - **Data Integrity**: Ensures data isn’t altered during transmission.
  - **Server Authentication**: Verifies the server’s identity (e.g., confirms `api.todo-service.com` is legitimate).
- **Example**: In a TODO service, a client sending a `POST /v1/tasks` request to `https://api.todo-service.com` uses HTTPS (port 443) to encrypt task data, ensuring it’s secure from interception.
- **Difference from HTTP**: HTTP is unencrypted and vulnerable to attacks like man-in-the-middle; HTTPS adds a secure layer.
- **Indicator**: Websites using HTTPS show a padlock icon in browsers and start with `https://`.

In backend development, HTTPS is essential for securing API endpoints, protecting user data (e.g., login credentials, task details), and ensuring trust in web applications.

### What is a password hash?

A **password hash** is a one-way transformation of a password into a fixed-length string of characters using a cryptographic hash function. It is used to securely store passwords in a database, making it difficult for attackers to retrieve the original password even if the database is compromised.

**Key Points**:

- **Purpose**: Protects passwords by storing them in an irreversible, encrypted form instead of plaintext.
- **How It Works**:
  - A hash function (e.g., bcrypt, SHA-256, Argon2) processes the password to produce a unique hash.
  - The hash is stored in the database instead of the actual password.
  - During login, the provided password is hashed and compared to the stored hash to verify authenticity.
- **Key Features**:
  - **One-Way**: Cannot be reversed to retrieve the original password.
  - **Deterministic**: The same password always produces the same hash (for verification).
  - **Collision-Resistant**: Different passwords should produce different hashes.
- **Salting**: A random string (salt) is added to the password before hashing to prevent attacks using precomputed tables (e.g., rainbow tables).
- **Example**: In a TODO service:
  - User password: `"MySecurePass123"`
  - Salt: `randomSalt123`
  - Hashed result (using bcrypt): `$2b$10$randomSalt123...hashedValue`
  - Stored in the `users` table for authentication during login.
- **Common Hash Functions**:
  - **bcrypt**: Adaptive, slow by design to resist brute-force attacks.
  - **Argon2**: Memory-hard, resistant to GPU-based attacks.
  - **SHA-256**: Faster but less secure for passwords without proper salting.

In backend development, password hashing is critical for securely storing user credentials, ensuring that even if a database is breached, the original passwords remain protected.

### What is SQL injection?

**SQL injection** is a security vulnerability in which an attacker manipulates a web application's database query by injecting malicious SQL code into user inputs (e.g., forms, URL parameters, or API payloads). This can allow unauthorized access to or manipulation of the database.

**Key Points**:

- **How It Works**: Attackers exploit poorly sanitized input fields to inject SQL commands that the database executes, altering the intended query behavior.
- **Impact**:
  - Unauthorized data access (e.g., retrieving all user data).
  - Data modification or deletion (e.g., changing or deleting tasks).
  - Bypassing authentication (e.g., logging in without valid credentials).
  - Potential database compromise or data leaks.
- **Example**: In a TODO service:
  - Normal query: `SELECT * FROM users WHERE username = 'john' AND password = 'pass123'`
  - Vulnerable input: User enters `' OR '1'='1` as the password.
  - Resulting query: `SELECT * FROM users WHERE username = 'john' AND password = '' OR '1'='1'`
  - This evaluates to true for all users, bypassing authentication.
- **Prevention**:
  - **Prepared Statements/Parameterized Queries**: Use placeholders for user inputs (e.g., `SELECT * FROM users WHERE username = ? AND password = ?`).
  - **Input Validation/Sanitization**: Restrict and clean user inputs to prevent malicious code.
  - **ORMs**: Use Object-Relational Mappers (e.g., SQLAlchemy, Sequelize) that handle inputs safely.
  - **Least Privilege**: Limit database user permissions to minimize damage.

In backend development, protecting against SQL injection is critical to secure database interactions in applications like a TODO service, ensuring user data and system integrity are maintained.

### What is XSS?

**XSS** (Cross-Site Scripting) is a security vulnerability in web applications where an attacker injects malicious scripts (typically JavaScript) into content that is then displayed to users. These scripts execute in the context of a victim’s browser, potentially compromising user data or interactions.

**Key Points**:

- **How It Works**: Attackers exploit unvalidated or unsanitized user inputs (e.g., form fields, URL parameters) to inject scripts that run when other users view the affected page or API response.
- **Types**:
  - **Stored XSS**: Malicious script is stored in the database and executed when users access the data (e.g., a comment with `<script>alert('hacked')</script>`).
  - **Reflected XSS**: Script is embedded in a URL or input and executed immediately when a user visits the manipulated link.
  - **DOM-Based XSS**: Script manipulates the browser’s Document Object Model (DOM) without server interaction.
- **Impact**:
  - Steal user data (e.g., cookies, session tokens).
  - Redirect users to malicious sites.
  - Deface websites or perform unauthorized actions (e.g., creating tasks in a TODO service).
- **Example**: In a TODO service:
  - An attacker submits a task title: `<script>stealCookies()</script>`.
  - If the title is displayed without sanitization, the script runs in users’ browsers when they view the task list.
- **Prevention**:
  - **Input Sanitization**: Escape or sanitize user inputs (e.g., convert `<` to `&lt;`).
  - **Output Encoding**: Encode data before rendering (e.g., use libraries like DOMPurify).
  - **Content Security Policy (CSP)**: Restrict script sources in browsers.
  - **Use Frameworks**: Modern frameworks (e.g., React, Angular) often escape outputs by default.
  - **Avoid eval()**: Never execute user input as code.

In backend development, preventing XSS is critical to protect users interacting with APIs or web interfaces, ensuring malicious scripts don’t compromise the application or user data in systems like a TODO service.

### What is CSRF?

**CSRF** (Cross-Site Request Forgery) is a security vulnerability in web applications where an attacker tricks an authenticated user into performing unintended actions on a trusted site without their knowledge or consent. It exploits the trust a website has in a user’s browser, which may automatically include credentials (e.g., cookies) with requests.

**Key Points**:

- **How It Works**: An attacker crafts a malicious request (e.g., via a link, image, or form) that, when triggered by a logged-in user, sends a request to the target site, leveraging the user’s active session to execute unauthorized actions.
- **Impact**:
  - Perform actions like changing account details, creating/deleting resources, or transferring funds.
  - Compromise user data or application integrity.
- **Example**: In a TODO service:
  - A user is logged into `https://api.todo-service.com`.
  - They visit a malicious site that includes an image tag: `<img src="https://api.todo-service.com/v1/tasks/delete/123">`.
  - The browser sends a `GET` request to delete task `123`, using the user’s session cookie, without their knowledge.
- **Prevention**:
  - **CSRF Tokens**: Include a unique, unpredictable token in legitimate requests (e.g., in forms or headers) that the server validates.
  - **SameSite Cookies**: Set cookies with `SameSite=Strict` or `SameSite=Lax` to restrict cross-site requests.
  - **Validate HTTP Methods**: Use POST instead of GET for state-changing actions and verify methods server-side.
  - **User Interaction**: Require explicit confirmation for sensitive actions (e.g., re-entering a password).
  - **CORS Policies**: Restrict cross-origin requests to trusted domains.

In backend development, preventing CSRF is crucial for securing APIs and web applications, ensuring that actions like creating or deleting tasks in a TODO service are performed only by authorized, intentional user requests.

### What is a session?

A **session** is a temporary, server-managed interaction between a client (e.g., a user's browser or app) and a server that maintains state information across multiple requests during a user's visit to a web application. It is used to track user activity, maintain login status, or store temporary data without requiring repeated authentication.

**Key Points**:

- **Purpose**: Preserves user-specific data (e.g., login status, preferences) across stateless HTTP requests.
- **How It Works**:
  - When a user logs in or starts interacting, the server creates a session and assigns a unique **session ID**.
  - The session ID is typically stored in a cookie or sent in requests (e.g., via headers).
  - The server stores session data (e.g., user ID, role) in memory, a database, or a cache (e.g., Redis).
  - The client includes the session ID in subsequent requests, allowing the server to retrieve the associated session data.
- **Example**: In a TODO service:
  - A user logs into `https://api.todo-service.com` with credentials.
  - The server creates a session, stores it (e.g., `session_id: abc123, user_id: 456`), and sends `abc123` to the client in a cookie.
  - When the user requests `GET /v1/tasks`, the browser sends the session ID, and the server verifies the user’s identity to return their tasks.
- **Features**:
  - **Expiration**: Sessions typically expire after a set time (e.g., 30 minutes) or on logout for security.
  - **Security**: Can be secured with HTTPS, secure cookies, and session tokens to prevent hijacking.
- **Session Storage**:
  - **Server-Side**: Session data stored on the server (e.g., in Redis, database).
  - **Client-Side**: Minimal data (session ID) stored in cookies or tokens (e.g., JWT for stateless sessions).
- **Use Case**: Maintains user authentication state, so a logged-in user can access protected endpoints like `POST /v1/tasks` without re-entering credentials.

In backend development, sessions are critical for managing user interactions in applications like a TODO service, ensuring a seamless and secure experience while maintaining state across requests.

### What is a cookie?

A **cookie** is a small piece of data stored by a web server on a client’s device (e.g., browser) and sent back to the server with subsequent requests. It is used to maintain state, track user activity, or store small amounts of information across HTTP requests, which are inherently stateless.

**Key Points**:

- **Purpose**: Enables persistence of user-specific data, such as session IDs, preferences, or tracking information, between requests.
- **How It Works**:
  - The server sends a cookie to the client via an HTTP response header (`Set-Cookie`).
  - The client (e.g., browser) stores the cookie and includes it in future requests to the same server via the `Cookie` header.
- **Components**:
  - **Name-Value Pair**: The key and data (e.g., `session_id=abc123`).
  - **Attributes**: Optional settings like:
    - `Expires` or `Max-Age`: When the cookie expires.
    - `Domain`: Which domains can access the cookie (e.g., `todo-service.com`).
    - `Path`: Which paths on the server the cookie applies to (e.g., `/v1`).
    - `Secure`: Ensures the cookie is only sent over HTTPS.
    - `HttpOnly`: Prevents client-side scripts from accessing the cookie (mitigates XSS).
    - `SameSite`: Controls cross-site request behavior (e.g., `Strict`, `Lax`, `None`).
- **Example**: In a TODO service:
  - After a user logs into `https://api.todo-service.com`, the server sends a cookie: `Set-Cookie: session_id=abc123; Secure; HttpOnly; SameSite=Strict`.
  - The browser stores it and includes `Cookie: session_id=abc123` in subsequent requests (e.g., `GET /v1/tasks`), allowing the server to identify the user.
- **Types**:
  - **Session Cookies**: Temporary, deleted when the browser closes.
  - **Persistent Cookies**: Stored until they expire or are deleted.
- **Use Cases**:
  - Maintaining user sessions (e.g., staying logged in).
  - Storing user preferences (e.g., theme settings).
  - Tracking user behavior (e.g., analytics).

In backend development, cookies are critical for managing sessions and user state in applications like a TODO service, but they must be secured (e.g., with `Secure` and `HttpOnly`) to prevent attacks like XSS or session hijacking.

## Performance

### What is caching?

### What is load time?

### What is throughput?

### What is response time?

### What is scalability?

### What is vertical scaling?

### What is horizontal scaling?

### What is a bottleneck?

### What is optimization?

### What is indexing in databases?

## Concurrency

### What is a thread?

### What is a process?

### What is multitasking?

### What is parallelism?

### What is concurrency?

### What is a mutex?

### What is a semaphore?

### What is deadlock?

### What is race condition?

### What is synchronization?

## APIs and Services

### What is REST?

### What is SOAP?

### What is JSON?

### What is XML?

### What is a web service?

### What is microservices?

### What is monolithic architecture?

### What is an HTTP status code?

### What is GET method?

### What is POST method?

## Miscellaneous

### What is version control?

### What is Git?

### What is logging?

### What is debugging?

### What is an environment variable?

### What is a configuration file?

### What is deployment?

### What is hosting?

### What is a domain name?

### What is SSL?

### What is a certificate?

### What is OAuth?

### What is JWT?

### What is API key?

### What is rate limiting?

### What is throttling?

### What is pagination?

### What is sorting in queries?

### What is filtering in APIs?

### What is aggregation in databases?

### What is a join in SQL?

### What is a view in databases?

### What is a stored procedure?

### What is a trigger?

### What is NoSQL?

### What is a key-value store?

### What is a document database?

### What is a graph database?

### What is a relational database?

### What is ORM?
